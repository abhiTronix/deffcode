{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction \u00b6 DeFFcode is a powerful High-performance Real-time Video frames Generator that wraps FFmpeg pipeline inside a subprocess module for generating blazingly fast video frames in python The primary purpose of DeFFcode is to provide a cross-platform solution for fast and low-overhead decoding of a wide range of video streams into 3D ndarray frames while providing complete control over the underlying FFmpeg pipeline without the need to go deeper into hefty documentation and in just a few lines of python code. DeFFcode can extract frames in real-time with any custom specification imaginable such as Framerate, Resolution, Hardware decoding, Complex Filters into any pixel format while giving users the complete freedom to play with any desired FFmpeg supported parameter. On top of that, DeFFcode enables effortless and precise FFmpeg Frame Seeking natively. Finally, DeFFcode APIs are designed with simplicity, flexibility, and modularity in mind for the best developer experience. \u2009 Key Features \u00b6 DeFFcode APIs are build on FFmpeg - a leading multimedia framework , that gives you the following: Extremely exceptional real-time performance with low-memory footprints. Flexible API with access to almost every parameter available within FFmpeg. Fast dedicated Hardware-Accelerated Decoding . Precise FFmpeg Frame Seeking with pinpoint accuracy. Extensive support for real-time Complex FFmpeg Filters . Out-of-the-box support for Computer Vision libraries like OpenCV, Pytorch, etc. Support a wide range of media files, devices, image-sequence and network streams. Easier to ingest streams into any pixel format that FFmpeg supports. Lossless Transcoding support with WriteGear . Fewer hard dependencies, and easy to install. Designed modular for best developer experience. Cross-platform and runs on Python 3.7+ \u2009 Getting Started \u00b6 In case you're run into any problems, consult our Help section. If this is your first time using DeFFcode, head straight to the Installation Notes to install DeFFcode. The default function of DeFFcode's FFdecoder API is to generate 24-bit RGB (3D ndarray ) frames from the given source: # import the necessary packages from deffcode import FFdecoder # formulate the decoder with suitable source(for e.g. foo.mp4) decoder = FFdecoder ( \"foo.mp4\" ) . formulate () # grab RGB24(default) 3D frames from decoder for frame in decoder . generateFrame (): # lets print its shape print ( frame . shape ) # print metadata as `json.dump` print ( decoder . metadata ) # terminate the decoder decoder . terminate () For more in-depth usage, kindly refer our Basic Recipes and Advanced Recipes \u2009 Contributions \u00b6 Contributions are welcome, and greatly appreciated! Please read our Contribution Guidelines for more details. \u2009 Community Channel \u00b6 If you've come up with some new idea, or looking for the fastest way troubleshoot your problems. Please checkout our Gitter community channel \u27b6 \u2009 Become a Stargazer \u00b6 You can be a Stargazer by starring us on Github, it helps us a lot and you're making it easier for others to find & trust this library. Thanks! \u2009 Donations \u00b6 DeFFcode is free and open source and will always remain so. It is something I am doing with my own free time. If you would like to say thanks, please feel free to make a donation: kofiwidget2.init('Support Me on Ko-fi', '#eba100', 'W7W8WTYO');kofiwidget2.draw();","title":"Introduction"},{"location":"#introduction","text":"DeFFcode is a powerful High-performance Real-time Video frames Generator that wraps FFmpeg pipeline inside a subprocess module for generating blazingly fast video frames in python The primary purpose of DeFFcode is to provide a cross-platform solution for fast and low-overhead decoding of a wide range of video streams into 3D ndarray frames while providing complete control over the underlying FFmpeg pipeline without the need to go deeper into hefty documentation and in just a few lines of python code. DeFFcode can extract frames in real-time with any custom specification imaginable such as Framerate, Resolution, Hardware decoding, Complex Filters into any pixel format while giving users the complete freedom to play with any desired FFmpeg supported parameter. On top of that, DeFFcode enables effortless and precise FFmpeg Frame Seeking natively. Finally, DeFFcode APIs are designed with simplicity, flexibility, and modularity in mind for the best developer experience.","title":"Introduction"},{"location":"#key-features","text":"DeFFcode APIs are build on FFmpeg - a leading multimedia framework , that gives you the following: Extremely exceptional real-time performance with low-memory footprints. Flexible API with access to almost every parameter available within FFmpeg. Fast dedicated Hardware-Accelerated Decoding . Precise FFmpeg Frame Seeking with pinpoint accuracy. Extensive support for real-time Complex FFmpeg Filters . Out-of-the-box support for Computer Vision libraries like OpenCV, Pytorch, etc. Support a wide range of media files, devices, image-sequence and network streams. Easier to ingest streams into any pixel format that FFmpeg supports. Lossless Transcoding support with WriteGear . Fewer hard dependencies, and easy to install. Designed modular for best developer experience. Cross-platform and runs on Python 3.7+","title":"Key Features"},{"location":"#getting-started","text":"In case you're run into any problems, consult our Help section. If this is your first time using DeFFcode, head straight to the Installation Notes to install DeFFcode. The default function of DeFFcode's FFdecoder API is to generate 24-bit RGB (3D ndarray ) frames from the given source: # import the necessary packages from deffcode import FFdecoder # formulate the decoder with suitable source(for e.g. foo.mp4) decoder = FFdecoder ( \"foo.mp4\" ) . formulate () # grab RGB24(default) 3D frames from decoder for frame in decoder . generateFrame (): # lets print its shape print ( frame . shape ) # print metadata as `json.dump` print ( decoder . metadata ) # terminate the decoder decoder . terminate () For more in-depth usage, kindly refer our Basic Recipes and Advanced Recipes","title":"Getting Started"},{"location":"#contributions","text":"Contributions are welcome, and greatly appreciated! Please read our Contribution Guidelines for more details.","title":"Contributions"},{"location":"#community-channel","text":"If you've come up with some new idea, or looking for the fastest way troubleshoot your problems. Please checkout our Gitter community channel \u27b6","title":"Community Channel"},{"location":"#become-a-stargazer","text":"You can be a Stargazer by starring us on Github, it helps us a lot and you're making it easier for others to find & trust this library. Thanks!","title":"Become a Stargazer"},{"location":"#donations","text":"DeFFcode is free and open source and will always remain so. It is something I am doing with my own free time. If you would like to say thanks, please feel free to make a donation: kofiwidget2.init('Support Me on Ko-fi', '#eba100', 'W7W8WTYO');kofiwidget2.draw();","title":"Donations"},{"location":"changelog/","text":"Release Notes \u00b6 v0.2.0 (2021-03-21) \u00b6 New Features Sourcer API: Added metadata extraction and updation support: Added retrieve_metadata class method to Sourcer API. The retrieve_metadata will returns source metadata as python dictionary. Populated private source member values in dictionary with distinct keys. Added metadata property object function to FFdecoder API. The property object will retrieve source metadata form Sourcer API as dict and return it as JSON dump for pretty printing. Added Operational Mode as read-only property in metadata. Added metadata property object with setter() method for updating source metadata with user-defined dictionary. Implemented way to manually alter metadata keys and values for custom results. Added a new source_audio_samplerate metadata parameter: Re-implemented __extract_audio_bitrate internal function from scratch as __extract_audio_bitrate_nd_samplerate . Implemented new algorithm to extract both extract both audio bitrate and samplerate from given source. Updated regex patterns according to changes. Updated __contains_video and __contains_audio logic to support new changes. Added new -force_validate_source attribute to Sourcer API's sourcer_params dict parameter for special cases. Implemented check whether probe_stream() called or not in Sourcer API. Re-added missing verbose flags. Docs: Added new comprehensive documentation with Mkdocs: Added new icon ICO file with each layer of the favicon holds a different size of the image. Added new png images for best compatibility with different web browsers. Added new Deffcode banner image. Added new description and simplified wording. Added new image asset. Added new docs files. Added new index.md with introduction to project. Added new changelog.md. Added license.md Added new index.md with instructions for contributing in DeFFcode. Added issue.md with Issue Contribution Guidelines. Added PR.md with PR Contribution Guidelines. Added new image assets: logo and tagline Added separate LICENSE(under CC creative commons) and REAME.md for assets. Added new custom.js to add gitter sidecard support. Added new custom.css that brings standard and quality visual design experience to DeFFcode docs. Added new admonitions new and alert . Added new assets folders. Added new main.html extending base.html for defining custom site metadata. Added deFFcode banner image to metadata. Added twitter card and metadata. Added version warning for displaying a warning when the user visits any other version. Added footer sponsorship block. Added gitter card official JS script dist. Added new custom 404.html to handle HTTP status code 404 Not Found. Implemented custom theming with new CSS style. Added custom 404 image asset. Added new index.md with DeFFcode Installation notes. Added info about Supported Systems, Supported Python legacies, Prerequisites, Installation instructions. Added Pip and Source Installation instructions. Added new ffmpeg_install.md with machine-specific instructions for FFmpeg installation. Added new image assets. Added new index.md with different ways to help DeFFcode, other users, and the author. Added info about Starring and Watching DeFFcode on GitHub, Helping with open issues etc. Added Tweeter intent used for tweeting #deffode hastags easily. Added Kofi Donation link button. Added author contact links and left align avatar image. Added new get_help.md to get help with DeFFcode. Added DeFFcode gitter community link. Added other helpful links. Added New Badges. Added Basic Recipes with basic.md Added Example to save Keyframes as Image Added Example to display frames using OpenCV Library. Added Example to Generate Source Video Metadata. Added Example to Generate Video from frames using OpenCV Library. Added Example to Generate Video with Filter Applied. Added API References. Added mkdocstrings automatic documentation from sources. Added new index.md for FFdecoder API with its description and explaining its API. Added new index.md for Sourcer API with its description and explaining its API. Added ffhelper methods API references. Added utils methods API references. Added Advanced Recipes with advanced.md Added Example for GPU enabled Hardware-Accelerated Decoding. Added Example to Generate Video with Complex Filter Applied. Added Example to Generate Lossless Video using VidGear Library. Added Example to Generate Video from Image sequence. Added all API Parameters. Added new params.md for FFdecoder API explaining all its parameters. Added new params.md for Sourcer API explaining all its parameters. Added Mkdocs support with mkdocs.yml Implemented new mkdocs.yml with relevant parameters. Added extended material theme with overridden parts. Added site metadata with site_name, site_url, site_author, site_description, repo_name, repo_url, edit_uri, copyright etc. Added navigation under sections for easily accessing each document. Implemented Page tree for DeFFcode docs. Added features like navigation.tracking, navigation.indexes, navigation.top, search.suggest, search.highlight, search.share, content.code.annotate. Added separate palette [default]light(with primary:green accent: dark green) and [slate]dark(with primary:teal accent: light green) mode. Added Color palette toggle switch with icon material/home-lightning-bolt . Added support for all pymarkdown-extensions. Added google fonts for text: Quicksand and code: Fira Code . Added custom logo and icon for DeFFcode. Added support for plugins like search, git-revision-date-localized, minify. Added support for mkdocstrings plugin for auto-built API references. Added python handler for parsing python source-code to mkdocstrings . Improved source-code docs for compatibility with mkdocstrings . Added support for extensions like admonition , attr_list , codehilite , def_list , footnotes , meta , and toc . Added social icons and links. Added custom extra_css and extra_javascript . Added support for en (English) language. Added new badges to README.md for displaying current status of CI jobs and coverage. Added Raodmap to README.md CI: Automated CI support for different environments: Implemented auto-handling of dependencies installation, unit testing, and coverage report uploading. Added GitHub Action workflow for Linux envs: Added and configured CIlinux.yml to enable GitHub Action workflow for Linux-based Testing Envs. Added 3.7+ python-versions to build matrix. Added code coverage through codecov/codecov-action@v2 workflow for measuring unit-tests effectiveness. Implemented behavior to about coverage upload on timeout(error code 124 ) in pytests. Added Appveyor workflow for Windows envs: Add and configured appveyor.yml to enable Appveyor workflow for Windows-based Testing Envs. Added 3.7+ 64-bit python-versions to build matrix. Enabled fast_finish to exit immediately on error. Added Azure-Pipelines workflow for MacOS envs: Add and configured azure-pipelines.yml to enable Azure-Pipelines workflow for MacOS-based Testing Envs. Added code coverage through codecov workflow for measuring unit-tests effectiveness. Added online auto validation of codecov bash script using SH256SUM and sig files as recommended. Implemented behavior to about coverage upload on timeout(error code 124 ) in pytests. Added 3.7+ python-versions to build matrix. Added automated flake8 testing to discover any anomalies in code. Added master and dev branches for triggering CI. Implement new automated Docs Building and Deployment on gh-pages through GitHub Actions workflow: Added new workflow yaml docs_deployer.yml for automated docs deployment. Added different jobs with ubuntu-latest environement to build matrix. Added actions/checkout@v2 for repo checkout and actions/setup-python@v2 for python environment. Pinned python version to 3.8 for python environment in docs building. Added GIT_TOKEN , GIT_NAME , GIT_EMAIL environment variables through secrets. Added Mkdocs Material theme related python dependencies and environments. Added push on master and dev branch release with published as triggers. Pinned mkdocstrings==0.17.0 . Added new Automated Docs Versioning: Implemented Docs versioning through mike . Separate new workflow steps to handle different versions. Added step to auto-create RELEASE_NAME environment variable from DeFFcode version file. Update docs deploy workflow to support latest , release and dev builds. Added automatic release version extraction from GitHub events. Added Skip Duplicate Actions Workflow to DeFFcode Docs Deployer: Added Skip Duplicate Actions( fkirc/skip-duplicate-actions@master ) Workflow to DeFFcode Docs Deployer to prevent redundant duplicate workflow-runs. Maintenance: New DeFFcode project issue and PR templates: Added PR template: Added a pull request template( PULL_REQUEST_TEMPLATE.md ) for project contributors to automatically see the template's contents in the pull request body. Added Brief Description, Requirements / Checklist, Related Issue, Context, Types of changes blocks. Added Proposal, Bug-Report and Question templates: Created an ISSUE_TEMPLATE subdirectory to contain multiple issue templates. Add manually-created Proposal( proposal.md ) and Question( question.md ) issue template for project contributors to automatically see the template's contents in the issue body. Added Brief Description, Acknowledgment, Context, Current Environment, Any Other Information like blocks. Add an manually-created Bug Report( bug_report.md ) issue template to ISSUE_TEMPLATE subdirectory for project contributors to automatically see the template's contents in the issue body. Added Brief Description, Acknowledgment, Context, Current Environment, Expected Behavior, Actual Behavior, Possible Fix, Steps to reproduce, Miscellaneous like blocks. Added YAML frontmatter to each issue template to pre-fill the issue title, automatically add labels and assignees, and give the template a name and description. Added a config.yml file to the .github/ISSUE_TEMPLATE folder to customize the issue template chooser that people see when creating a new issue. Set blank_issues_enabled parameter to false to encourage contributors to use issue templates. Added contact_links parameter with gitter community link to receive regular issues outside of GitHub. Added new FUNDING.yml with ko-fi donation link. Added .gitattributes for DeFFcode, that set the default behavior, in case people don't have core.autocrlf set. Imported Codecov config(codecov.yml) from vidgear to modify coverage threshold, primary branch, ignored files, and other parameters. Tests: Added DeFFcode unit tests with pytest : Added essential.py for defining all essential functions necessary for DeFFcode unit tests. Added return_static_ffmpeg , remove_file_safe , return_testvideo_path , return_generated_frames_path, actual_frame_count_n_frame_size essential functions. Added is_windows global variable. Added related imports and logging. Added __init__.py . Moved all files to test folder. Added DeFFcode's utils unit tests with pytest. Added new test_loggerhandler and test_dict2Args tests. Added DeFFcode's ffhelper unit tests with pytest. Added new test_ffmpeg_binaries_download , test_validate_ffmpeg , test_get_valid_ffmpeg_path , test_check_sp_output , test_is_valid_url , test_is_valid_image_seq , and test_validate_imgseqdir parametrize tests. Added DeFFcode's Sourcer API unit tests with pytest. Added new test_source and test_probe_stream_n_retrieve_metadata parametrize tests. Added DeFFcode's FFdecoder API unit tests with pytest. Added new test_source_playback , test_frame_format , test_metadata , test_seek_n_save , and test_FFdecoder_params parametrize unit tests. Added related imports and logging. Added unit test for delete_file_safe utils function. Bash: \ud83d\udd27 Imported prepare_dataset.sh from vidgear for downloading pytest datasets to temp dir. Updates/Improvements API: FFdecoder API: Removed redundant forcing -r FFmpeg parameter for image sequences as source. Removed redundant checks on -vf FFmpeg parameter. FFmpeg parameter -s will be discarded in favor of -custom_resolution attribute. Replaced -constant_framerate with FFmpeg -framerate attribute. Replaced -custom_source_params with correct -custom_sourcer_params attribute. Renamed operational_mode metadata parameter to ffdecoder_operational_mode . Sourcer API: Converted all Sourcer APIs public available variables into private ones for stability. All Sourcer's publicly accessed variable metadata values in FFdecoder, therefore replaced with dictionary counterparts. Moved FFmpeg path validation and handling to Sourcer from FFdecoder API. Moved -ffmpeg_download_path dictionary attribute to Sourcer API's sourcer_params parameter. Moved dependencies and related functions. CI: Excluded dev branch from triggering workflow on any environment. Updated yaml files to exclude beta dev branch from triggering workflow on any environment. Restricted codecov to use only master branch. Re-implemented fkirc/skip-duplicate-actions@master to Skip individual deploy steps instead of Skip entire jobs Docs: Updated PR.md Added instructions to download prepare_dataset.sh using curl. Updated dependencies for pytest . Updated advanced.md Updated generating Video from Image sequence to save video using OpenCV writer instead of WriteGear API. Added frame_format=\"bgr24\" and additional instructions regarding OpenCV writer. Updated example codes with new changes. Rearranged examples placement. Updates to custom.css Added donation sponsor link in page footer with heart animation. Added bouncing heart animation through pure CSS. Added Bold property to currently highlighted link in Navigation Bar. Updated Navigation Bar title font size. Updated version list text to uppercase and bold. Updated icon for task list unchecked. Added more top-padding to docs heading. Updated Block quote symbol and theming. Updated Custom Button theming to match docs. Added new custom classes to create shadow effect in dark mode for better visibility. Updated dark mode theme \"slate\" hue to 285. Updated admonitions colors. Updated gitter sidecard UI colors and properties. Reflected recent changes in Sourcer and FFdecoder API's metadata. Updated sample code formatting from sh to json . Added missing docs for delete_file_safe utils function. Updated Download Test Datasets instructions. Updated contribution guidelines and installation docs with related changes. Updated License Notice. Updated code comments. Updated README.md Updated Roadmap. Updated logging messages. Updated Deffcode Logo and Tagline to be dark-mode friendly. Adjusted asset alignment. Updated example code. Updated Installation instructions, Requirements and Roadmap. Corrected links to documents. Updated project description. Updated LICENSE. Updated indentation and code comments Re-aligned text and images in README.md Adjusted image classes and width. Maintenance: Updated LICENSE notice to add vidgear notice. Bumped version to 0.2.0 Added useful comments for convenience. Breaking Updates/Changes Sourcer API will now raises Assertion error if probe_stream() not called before calling retrieve_metadata() . Only -framerate values greater than 0.0 are now valid. Renamed decode_stream to probe_stream in Sourcer API. Any of video bitrate or video framerate are sufficient to validate if source contains valid video stream(s). Any of audio bitrate or audio samplerate are sufficient to validate if source contains valid audio stream(s). Bug-fixes APIs: Added missing delete_file_safe function in utils. Imported delete_file_safe from vidgear to safely deletes files at given path. Fixed forward slash bugs in regex patterns. Fixed IndexError when no bitrate was discovered in given source. Fixed FFmpeg subprocess pipeline not terminating gracefully in FFdecoder API. Fixed __version__ not defined in DeFFcode's __init__.py that throws AttributeError: module 'deffcode' has no attribute '__version__' on query. Added necessary import in __init__.py . Docs: Fixed missing \"-vcodec\": \"h264_cuvid\" value in example code. Fixed typos in filenames in utils.py Fixed internal missing or invalid hyperlinks. Fixed improper docs context and typos. Fixed year in license notice. Fixed content spacing. Fixed Gitter Community Link in Mkdocs. Fixed typos in README.md. Fixed typos in license notices. Fixed typos in code comments. Fixed typos in example code. CI: Fixed missing FFmpeg dependency bug in GitHub Actions. Fixes typo in Docs Deployer yaml. Fixed if condition skipping when need is skipping Maintenance: Added missing imports. Fixed redundant conditional logics. Removed or Replaced redundant conditions and definitions. Fixed minor typos in templates. Pull Requests PR #5 PR #6 PR #8 PR #9 PR #11 PR #12 PR #13 PR #14 v0.1.0 (2021-03-07) \u00b6 New Features Open-Sourced DeFFcode under the Apache 2.0 License. Added new Classes(APIs): FFdecoder: Performant Real-time Video frames Generator for generating blazingly fast video frames(RGB ndarray by default). Sourcer: Extracts source video metadata (bitrate, resolution, framerate, nframes etc.) using its subprocess FFmpeg output. Added new Helper functions: ffhelper: Backend FFmpeg Wrapper that handles all subprocess transactions and gather data. utils: Handles all additional Utilizes required for functioning of DeFFcode. First PyPi Release: Released DeFFcode to Python Package Index (PyPI) Added setup.py and related metadata. Added version.py Docs: Added abstract and related information in README.md Added installation instructions. Added preliminary usage examples. Maintenance: Added LICENSE. Added .gitignore Updates/Improvements Maintenance: Bumped version to 0.1.0 Updated LICENSE notice to add vidgear code usage notice. Breaking Updates/Changes Fixed support for Python-3.7 and above legacies only. Bug-fixes Docs: Fixed hyperlinks in README. Fixed indentation and spacing. Fixed typos and updated context. Removed dead code.","title":"Changelog"},{"location":"changelog/#release-notes","text":"","title":"Release Notes"},{"location":"changelog/#v020-2021-03-21","text":"New Features Sourcer API: Added metadata extraction and updation support: Added retrieve_metadata class method to Sourcer API. The retrieve_metadata will returns source metadata as python dictionary. Populated private source member values in dictionary with distinct keys. Added metadata property object function to FFdecoder API. The property object will retrieve source metadata form Sourcer API as dict and return it as JSON dump for pretty printing. Added Operational Mode as read-only property in metadata. Added metadata property object with setter() method for updating source metadata with user-defined dictionary. Implemented way to manually alter metadata keys and values for custom results. Added a new source_audio_samplerate metadata parameter: Re-implemented __extract_audio_bitrate internal function from scratch as __extract_audio_bitrate_nd_samplerate . Implemented new algorithm to extract both extract both audio bitrate and samplerate from given source. Updated regex patterns according to changes. Updated __contains_video and __contains_audio logic to support new changes. Added new -force_validate_source attribute to Sourcer API's sourcer_params dict parameter for special cases. Implemented check whether probe_stream() called or not in Sourcer API. Re-added missing verbose flags. Docs: Added new comprehensive documentation with Mkdocs: Added new icon ICO file with each layer of the favicon holds a different size of the image. Added new png images for best compatibility with different web browsers. Added new Deffcode banner image. Added new description and simplified wording. Added new image asset. Added new docs files. Added new index.md with introduction to project. Added new changelog.md. Added license.md Added new index.md with instructions for contributing in DeFFcode. Added issue.md with Issue Contribution Guidelines. Added PR.md with PR Contribution Guidelines. Added new image assets: logo and tagline Added separate LICENSE(under CC creative commons) and REAME.md for assets. Added new custom.js to add gitter sidecard support. Added new custom.css that brings standard and quality visual design experience to DeFFcode docs. Added new admonitions new and alert . Added new assets folders. Added new main.html extending base.html for defining custom site metadata. Added deFFcode banner image to metadata. Added twitter card and metadata. Added version warning for displaying a warning when the user visits any other version. Added footer sponsorship block. Added gitter card official JS script dist. Added new custom 404.html to handle HTTP status code 404 Not Found. Implemented custom theming with new CSS style. Added custom 404 image asset. Added new index.md with DeFFcode Installation notes. Added info about Supported Systems, Supported Python legacies, Prerequisites, Installation instructions. Added Pip and Source Installation instructions. Added new ffmpeg_install.md with machine-specific instructions for FFmpeg installation. Added new image assets. Added new index.md with different ways to help DeFFcode, other users, and the author. Added info about Starring and Watching DeFFcode on GitHub, Helping with open issues etc. Added Tweeter intent used for tweeting #deffode hastags easily. Added Kofi Donation link button. Added author contact links and left align avatar image. Added new get_help.md to get help with DeFFcode. Added DeFFcode gitter community link. Added other helpful links. Added New Badges. Added Basic Recipes with basic.md Added Example to save Keyframes as Image Added Example to display frames using OpenCV Library. Added Example to Generate Source Video Metadata. Added Example to Generate Video from frames using OpenCV Library. Added Example to Generate Video with Filter Applied. Added API References. Added mkdocstrings automatic documentation from sources. Added new index.md for FFdecoder API with its description and explaining its API. Added new index.md for Sourcer API with its description and explaining its API. Added ffhelper methods API references. Added utils methods API references. Added Advanced Recipes with advanced.md Added Example for GPU enabled Hardware-Accelerated Decoding. Added Example to Generate Video with Complex Filter Applied. Added Example to Generate Lossless Video using VidGear Library. Added Example to Generate Video from Image sequence. Added all API Parameters. Added new params.md for FFdecoder API explaining all its parameters. Added new params.md for Sourcer API explaining all its parameters. Added Mkdocs support with mkdocs.yml Implemented new mkdocs.yml with relevant parameters. Added extended material theme with overridden parts. Added site metadata with site_name, site_url, site_author, site_description, repo_name, repo_url, edit_uri, copyright etc. Added navigation under sections for easily accessing each document. Implemented Page tree for DeFFcode docs. Added features like navigation.tracking, navigation.indexes, navigation.top, search.suggest, search.highlight, search.share, content.code.annotate. Added separate palette [default]light(with primary:green accent: dark green) and [slate]dark(with primary:teal accent: light green) mode. Added Color palette toggle switch with icon material/home-lightning-bolt . Added support for all pymarkdown-extensions. Added google fonts for text: Quicksand and code: Fira Code . Added custom logo and icon for DeFFcode. Added support for plugins like search, git-revision-date-localized, minify. Added support for mkdocstrings plugin for auto-built API references. Added python handler for parsing python source-code to mkdocstrings . Improved source-code docs for compatibility with mkdocstrings . Added support for extensions like admonition , attr_list , codehilite , def_list , footnotes , meta , and toc . Added social icons and links. Added custom extra_css and extra_javascript . Added support for en (English) language. Added new badges to README.md for displaying current status of CI jobs and coverage. Added Raodmap to README.md CI: Automated CI support for different environments: Implemented auto-handling of dependencies installation, unit testing, and coverage report uploading. Added GitHub Action workflow for Linux envs: Added and configured CIlinux.yml to enable GitHub Action workflow for Linux-based Testing Envs. Added 3.7+ python-versions to build matrix. Added code coverage through codecov/codecov-action@v2 workflow for measuring unit-tests effectiveness. Implemented behavior to about coverage upload on timeout(error code 124 ) in pytests. Added Appveyor workflow for Windows envs: Add and configured appveyor.yml to enable Appveyor workflow for Windows-based Testing Envs. Added 3.7+ 64-bit python-versions to build matrix. Enabled fast_finish to exit immediately on error. Added Azure-Pipelines workflow for MacOS envs: Add and configured azure-pipelines.yml to enable Azure-Pipelines workflow for MacOS-based Testing Envs. Added code coverage through codecov workflow for measuring unit-tests effectiveness. Added online auto validation of codecov bash script using SH256SUM and sig files as recommended. Implemented behavior to about coverage upload on timeout(error code 124 ) in pytests. Added 3.7+ python-versions to build matrix. Added automated flake8 testing to discover any anomalies in code. Added master and dev branches for triggering CI. Implement new automated Docs Building and Deployment on gh-pages through GitHub Actions workflow: Added new workflow yaml docs_deployer.yml for automated docs deployment. Added different jobs with ubuntu-latest environement to build matrix. Added actions/checkout@v2 for repo checkout and actions/setup-python@v2 for python environment. Pinned python version to 3.8 for python environment in docs building. Added GIT_TOKEN , GIT_NAME , GIT_EMAIL environment variables through secrets. Added Mkdocs Material theme related python dependencies and environments. Added push on master and dev branch release with published as triggers. Pinned mkdocstrings==0.17.0 . Added new Automated Docs Versioning: Implemented Docs versioning through mike . Separate new workflow steps to handle different versions. Added step to auto-create RELEASE_NAME environment variable from DeFFcode version file. Update docs deploy workflow to support latest , release and dev builds. Added automatic release version extraction from GitHub events. Added Skip Duplicate Actions Workflow to DeFFcode Docs Deployer: Added Skip Duplicate Actions( fkirc/skip-duplicate-actions@master ) Workflow to DeFFcode Docs Deployer to prevent redundant duplicate workflow-runs. Maintenance: New DeFFcode project issue and PR templates: Added PR template: Added a pull request template( PULL_REQUEST_TEMPLATE.md ) for project contributors to automatically see the template's contents in the pull request body. Added Brief Description, Requirements / Checklist, Related Issue, Context, Types of changes blocks. Added Proposal, Bug-Report and Question templates: Created an ISSUE_TEMPLATE subdirectory to contain multiple issue templates. Add manually-created Proposal( proposal.md ) and Question( question.md ) issue template for project contributors to automatically see the template's contents in the issue body. Added Brief Description, Acknowledgment, Context, Current Environment, Any Other Information like blocks. Add an manually-created Bug Report( bug_report.md ) issue template to ISSUE_TEMPLATE subdirectory for project contributors to automatically see the template's contents in the issue body. Added Brief Description, Acknowledgment, Context, Current Environment, Expected Behavior, Actual Behavior, Possible Fix, Steps to reproduce, Miscellaneous like blocks. Added YAML frontmatter to each issue template to pre-fill the issue title, automatically add labels and assignees, and give the template a name and description. Added a config.yml file to the .github/ISSUE_TEMPLATE folder to customize the issue template chooser that people see when creating a new issue. Set blank_issues_enabled parameter to false to encourage contributors to use issue templates. Added contact_links parameter with gitter community link to receive regular issues outside of GitHub. Added new FUNDING.yml with ko-fi donation link. Added .gitattributes for DeFFcode, that set the default behavior, in case people don't have core.autocrlf set. Imported Codecov config(codecov.yml) from vidgear to modify coverage threshold, primary branch, ignored files, and other parameters. Tests: Added DeFFcode unit tests with pytest : Added essential.py for defining all essential functions necessary for DeFFcode unit tests. Added return_static_ffmpeg , remove_file_safe , return_testvideo_path , return_generated_frames_path, actual_frame_count_n_frame_size essential functions. Added is_windows global variable. Added related imports and logging. Added __init__.py . Moved all files to test folder. Added DeFFcode's utils unit tests with pytest. Added new test_loggerhandler and test_dict2Args tests. Added DeFFcode's ffhelper unit tests with pytest. Added new test_ffmpeg_binaries_download , test_validate_ffmpeg , test_get_valid_ffmpeg_path , test_check_sp_output , test_is_valid_url , test_is_valid_image_seq , and test_validate_imgseqdir parametrize tests. Added DeFFcode's Sourcer API unit tests with pytest. Added new test_source and test_probe_stream_n_retrieve_metadata parametrize tests. Added DeFFcode's FFdecoder API unit tests with pytest. Added new test_source_playback , test_frame_format , test_metadata , test_seek_n_save , and test_FFdecoder_params parametrize unit tests. Added related imports and logging. Added unit test for delete_file_safe utils function. Bash: \ud83d\udd27 Imported prepare_dataset.sh from vidgear for downloading pytest datasets to temp dir. Updates/Improvements API: FFdecoder API: Removed redundant forcing -r FFmpeg parameter for image sequences as source. Removed redundant checks on -vf FFmpeg parameter. FFmpeg parameter -s will be discarded in favor of -custom_resolution attribute. Replaced -constant_framerate with FFmpeg -framerate attribute. Replaced -custom_source_params with correct -custom_sourcer_params attribute. Renamed operational_mode metadata parameter to ffdecoder_operational_mode . Sourcer API: Converted all Sourcer APIs public available variables into private ones for stability. All Sourcer's publicly accessed variable metadata values in FFdecoder, therefore replaced with dictionary counterparts. Moved FFmpeg path validation and handling to Sourcer from FFdecoder API. Moved -ffmpeg_download_path dictionary attribute to Sourcer API's sourcer_params parameter. Moved dependencies and related functions. CI: Excluded dev branch from triggering workflow on any environment. Updated yaml files to exclude beta dev branch from triggering workflow on any environment. Restricted codecov to use only master branch. Re-implemented fkirc/skip-duplicate-actions@master to Skip individual deploy steps instead of Skip entire jobs Docs: Updated PR.md Added instructions to download prepare_dataset.sh using curl. Updated dependencies for pytest . Updated advanced.md Updated generating Video from Image sequence to save video using OpenCV writer instead of WriteGear API. Added frame_format=\"bgr24\" and additional instructions regarding OpenCV writer. Updated example codes with new changes. Rearranged examples placement. Updates to custom.css Added donation sponsor link in page footer with heart animation. Added bouncing heart animation through pure CSS. Added Bold property to currently highlighted link in Navigation Bar. Updated Navigation Bar title font size. Updated version list text to uppercase and bold. Updated icon for task list unchecked. Added more top-padding to docs heading. Updated Block quote symbol and theming. Updated Custom Button theming to match docs. Added new custom classes to create shadow effect in dark mode for better visibility. Updated dark mode theme \"slate\" hue to 285. Updated admonitions colors. Updated gitter sidecard UI colors and properties. Reflected recent changes in Sourcer and FFdecoder API's metadata. Updated sample code formatting from sh to json . Added missing docs for delete_file_safe utils function. Updated Download Test Datasets instructions. Updated contribution guidelines and installation docs with related changes. Updated License Notice. Updated code comments. Updated README.md Updated Roadmap. Updated logging messages. Updated Deffcode Logo and Tagline to be dark-mode friendly. Adjusted asset alignment. Updated example code. Updated Installation instructions, Requirements and Roadmap. Corrected links to documents. Updated project description. Updated LICENSE. Updated indentation and code comments Re-aligned text and images in README.md Adjusted image classes and width. Maintenance: Updated LICENSE notice to add vidgear notice. Bumped version to 0.2.0 Added useful comments for convenience. Breaking Updates/Changes Sourcer API will now raises Assertion error if probe_stream() not called before calling retrieve_metadata() . Only -framerate values greater than 0.0 are now valid. Renamed decode_stream to probe_stream in Sourcer API. Any of video bitrate or video framerate are sufficient to validate if source contains valid video stream(s). Any of audio bitrate or audio samplerate are sufficient to validate if source contains valid audio stream(s). Bug-fixes APIs: Added missing delete_file_safe function in utils. Imported delete_file_safe from vidgear to safely deletes files at given path. Fixed forward slash bugs in regex patterns. Fixed IndexError when no bitrate was discovered in given source. Fixed FFmpeg subprocess pipeline not terminating gracefully in FFdecoder API. Fixed __version__ not defined in DeFFcode's __init__.py that throws AttributeError: module 'deffcode' has no attribute '__version__' on query. Added necessary import in __init__.py . Docs: Fixed missing \"-vcodec\": \"h264_cuvid\" value in example code. Fixed typos in filenames in utils.py Fixed internal missing or invalid hyperlinks. Fixed improper docs context and typos. Fixed year in license notice. Fixed content spacing. Fixed Gitter Community Link in Mkdocs. Fixed typos in README.md. Fixed typos in license notices. Fixed typos in code comments. Fixed typos in example code. CI: Fixed missing FFmpeg dependency bug in GitHub Actions. Fixes typo in Docs Deployer yaml. Fixed if condition skipping when need is skipping Maintenance: Added missing imports. Fixed redundant conditional logics. Removed or Replaced redundant conditions and definitions. Fixed minor typos in templates. Pull Requests PR #5 PR #6 PR #8 PR #9 PR #11 PR #12 PR #13 PR #14","title":"v0.2.0 (2021-03-21)"},{"location":"changelog/#v010-2021-03-07","text":"New Features Open-Sourced DeFFcode under the Apache 2.0 License. Added new Classes(APIs): FFdecoder: Performant Real-time Video frames Generator for generating blazingly fast video frames(RGB ndarray by default). Sourcer: Extracts source video metadata (bitrate, resolution, framerate, nframes etc.) using its subprocess FFmpeg output. Added new Helper functions: ffhelper: Backend FFmpeg Wrapper that handles all subprocess transactions and gather data. utils: Handles all additional Utilizes required for functioning of DeFFcode. First PyPi Release: Released DeFFcode to Python Package Index (PyPI) Added setup.py and related metadata. Added version.py Docs: Added abstract and related information in README.md Added installation instructions. Added preliminary usage examples. Maintenance: Added LICENSE. Added .gitignore Updates/Improvements Maintenance: Bumped version to 0.1.0 Updated LICENSE notice to add vidgear code usage notice. Breaking Updates/Changes Fixed support for Python-3.7 and above legacies only. Bug-fixes Docs: Fixed hyperlinks in README. Fixed indentation and spacing. Fixed typos and updated context. Removed dead code.","title":"v0.1.0 (2021-03-07)"},{"location":"license/","text":"License \u00b6 This library is released under the Apache 2.0 License . Copyright Notice \u00b6 Copyright (c) 2021 Abhishek Thakur(@abhiTronix) <abhi.una12@gmail.com> Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"License"},{"location":"license/#license","text":"This library is released under the Apache 2.0 License .","title":"License"},{"location":"license/#copyright-notice","text":"Copyright (c) 2021 Abhishek Thakur(@abhiTronix) <abhi.una12@gmail.com> Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.","title":"Copyright Notice"},{"location":"contribution/","text":"Contribution Overview \u00b6 Contributions are always welcomed We'd love your contribution to DeFFcode in order to fix bugs or to implement new features! Submission Guidelines \u00b6 Submitting an Issue Guidelines \u27b6 Submitting Pull Request(PR) Guidelines \u27b6 Submission Contexts \u00b6 Got a question or problem? \u00b6 For quick questions, please refrain from opening an issue, instead you can reach us on Gitter community channel. Found a typo? \u00b6 There's no need to contribute for some typos. Just reach us on Gitter \u27b6 community channel, We will correct them in (less than) no time. Found a bug? \u00b6 If you encountered a bug, you can help us by submitting an issue in our GitHub repository. Even better, you can submit a Pull Request(PR) with a fix, but make sure to read the guidelines \u27b6 . Request for a feature/improvement? \u00b6 Subscribe to Github Repository You can subscribe our GitHub Repository to receive notifications through email for new pull requests, commits and issues that are created in DeFFcode. Learn more about it here \u27b6 You can request our GitHub Repository for a new feature/improvement based on the type of request: Please submit an issue with a proposal template for your request to explain how it benefits everyone in the community. Major Feature Requests: If you require a major feature for DeFFcode, then first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. The purposed feature, if accepted, may take time based on its complexity and availability/time-schedule of our maintainers, but once it's completed, you will be notified right away. Please be patient! Minor Feature Requests: Small features and bugs resolved on priority. You just have to submit an issue to our GitHub Repository.","title":"Overview"},{"location":"contribution/#contribution-overview","text":"Contributions are always welcomed We'd love your contribution to DeFFcode in order to fix bugs or to implement new features!","title":"Contribution Overview"},{"location":"contribution/#submission-guidelines","text":"Submitting an Issue Guidelines \u27b6 Submitting Pull Request(PR) Guidelines \u27b6","title":"Submission Guidelines"},{"location":"contribution/#submission-contexts","text":"","title":"Submission Contexts"},{"location":"contribution/#got-a-question-or-problem","text":"For quick questions, please refrain from opening an issue, instead you can reach us on Gitter community channel.","title":"Got a question or problem?"},{"location":"contribution/#found-a-typo","text":"There's no need to contribute for some typos. Just reach us on Gitter \u27b6 community channel, We will correct them in (less than) no time.","title":"Found a typo?"},{"location":"contribution/#found-a-bug","text":"If you encountered a bug, you can help us by submitting an issue in our GitHub repository. Even better, you can submit a Pull Request(PR) with a fix, but make sure to read the guidelines \u27b6 .","title":"Found a bug?"},{"location":"contribution/#request-for-a-featureimprovement","text":"Subscribe to Github Repository You can subscribe our GitHub Repository to receive notifications through email for new pull requests, commits and issues that are created in DeFFcode. Learn more about it here \u27b6 You can request our GitHub Repository for a new feature/improvement based on the type of request: Please submit an issue with a proposal template for your request to explain how it benefits everyone in the community. Major Feature Requests: If you require a major feature for DeFFcode, then first open an issue and outline your proposal so that it can be discussed. This will also allow us to better coordinate our efforts, prevent duplication of work, and help you to craft the change so that it is successfully accepted into the project. The purposed feature, if accepted, may take time based on its complexity and availability/time-schedule of our maintainers, but once it's completed, you will be notified right away. Please be patient! Minor Feature Requests: Small features and bugs resolved on priority. You just have to submit an issue to our GitHub Repository.","title":"Request for a feature/improvement?"},{"location":"contribution/PR/","text":"Submitting Pull Request(PR) Guidelines: \u00b6 The following guidelines tells you how to submit a valid PR for DeFFcode: Working on your first Pull Request for DeFFcode? If you don't know how to contribute to an Open Source Project on GitHub, then You can learn about it from here \u27b6 If you're stuck at something, please join our Gitter community channel . We will help you get started! Kindly follow the EXEMPLARY tag for some finest PR examples. Clone branch for PR \u00b6 You can clone your Forked remote git to local and create your PR working branch as a sub-branch of latest master branch as follows: Make sure the master branch of your Forked repository is up-to-date with DeFFcode, before starting working on a Pull Request. # clone your forked repository(change with your username) and get inside git clone https://github.com/ { YOUR USERNAME } /DeFFcode.git && cd DeFFcode # pull any recent updates git pull # Now create your new branch with suitable name(such as \"subbranch_of_master\") git checkout -b subbranch_of_master Now after working with this newly created branch for your Pull Request, you can commit and push or merge it locally or remotely as usual. PR Submission Checklist \u00b6 There are some important checks you need to perform while submitting your Pull Request(s) for DeFFcode library: Submit a Related Issue: The first thing you do is submit an issue with a proposal template for your work first and then work on your Pull Request. Submit a Draft Pull Request: Submit the draft pull request from the first day of your development. Add a brief but descriptive title for your PR. Explain what the PR adds, fixes, or improves. In case of bug fixes, add a new unit test case that would fail against your bug fix. Provide output or screenshots, if you can. Make sure your pull request passed all the CI checks (triggers automatically on pushing commits against dev branch) . If it's somehow failing, then ask the maintainer for a review. Click \"ready for review\" when finished. Test, Format & lint code locally: Make sure to test, format, and lint the modified code locally before every commit. The details are discussed below \u27b6 Make sensible commit messages: If your pull request fixes a separate issue number, remember to include \"resolves #issue_number\" in the commit message. Learn more about it here \u27b6 . Keep the commit message concisely as much as possible at every submit. You can make a supplement to the previous commit with git commit --amend command. Perform Integrity Checks: Any duplicate pull request will be Rejected! Search GitHub if there's a similar open or closed PR that relates to your submission. Check if your purpose code matches the overall direction, simplicity, and structure of the DeFFcode and improves it. Retain copyright for your contributions, but also agree to license them for usage by the project and author(s) under the Apache 2.0 license \u27b6 . Link your Issues: For more information on Linking a pull request to an issue, See this wiki doc\u27b6 Finally, when you're confident enough, make your pull request public. You can link an issue to a pull request manually or using a supported keyword in the pull request description. It helps collaborators see that someone is working on the issue. Testing, Formatting & Linting \u00b6 All Pull Request(s) must be tested, formatted & linted against our library standards as discussed below: Requirements \u00b6 Testing DeFFcode requires additional test dependencies and dataset, which can be handled manually as follows: Install additional python libraries: You can easily install these dependencies via pip: # Install opencv(only if not installed previously) pip install opencv-python # install rest of dependencies pip install --upgrade flake8 black pytest vidgear [ core ] Download Tests Dataset: To perform tests, you also need to download additional dataset (to your temp dir) by running prepare_dataset.sh bash script as follows: # On linux or macOS chmod +x scripts/bash/prepare_dataset.sh ./scripts/bash/prepare_dataset.sh # On Windows sh scripts/bash/prepare_dataset.sh Running Tests \u00b6 All tests can be run with pytest ( in DeFFcode's root folder ) as follows: pytest -sv #-sv for verbose output. Formatting & Linting \u00b6 For formatting and linting, following libraries are used: Flake8: You must run flake8 linting for checking the code base against the coding style (PEP8), programming errors and other cyclomatic complexity: flake8 { source_file_or_directory } --count --select = E9,F63,F7,F82 --show-source --statistics Black: DeFFcode follows black formatting to make code review faster by producing the smallest diffs possible. You must run it with sensible defaults as follows: black { source_file_or_directory } Frequently Asked Questions \u00b6 Q1. Why do my changes taking so long to be Reviewed and/or Merged? Submission Aftermaths After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository. The changes will remain in dev branch until next DeFFcode version is released, then it will be merged into master branch. After a successful Merge, your newer contributions will be given priority over others. Pull requests will be reviewed by the maintainers and the rationale behind the maintainer\u2019s decision to accept or deny the changes will be posted in the pull request. Please wait for our code review and approval, possibly enhancing your change on request. Q2. Would you accept a huge Pull Request with Lots of Changes? First, make sure that the changes are somewhat related. Otherwise, please create separate pull requests. Anyway, before submitting a huge change, it's probably a good idea to open an issue in the DeFFcode Github repository to ask the maintainers if they agree with your proposed changes. Otherwise, they could refuse your proposal after you put all that hard work into making the changes. We definitely don't want you to waste your time!","title":"Pull Request(PR) Guidelines"},{"location":"contribution/PR/#submitting-pull-requestpr-guidelines","text":"The following guidelines tells you how to submit a valid PR for DeFFcode: Working on your first Pull Request for DeFFcode? If you don't know how to contribute to an Open Source Project on GitHub, then You can learn about it from here \u27b6 If you're stuck at something, please join our Gitter community channel . We will help you get started! Kindly follow the EXEMPLARY tag for some finest PR examples.","title":"Submitting Pull Request(PR) Guidelines:"},{"location":"contribution/PR/#clone-branch-for-pr","text":"You can clone your Forked remote git to local and create your PR working branch as a sub-branch of latest master branch as follows: Make sure the master branch of your Forked repository is up-to-date with DeFFcode, before starting working on a Pull Request. # clone your forked repository(change with your username) and get inside git clone https://github.com/ { YOUR USERNAME } /DeFFcode.git && cd DeFFcode # pull any recent updates git pull # Now create your new branch with suitable name(such as \"subbranch_of_master\") git checkout -b subbranch_of_master Now after working with this newly created branch for your Pull Request, you can commit and push or merge it locally or remotely as usual.","title":"Clone branch for PR"},{"location":"contribution/PR/#pr-submission-checklist","text":"There are some important checks you need to perform while submitting your Pull Request(s) for DeFFcode library: Submit a Related Issue: The first thing you do is submit an issue with a proposal template for your work first and then work on your Pull Request. Submit a Draft Pull Request: Submit the draft pull request from the first day of your development. Add a brief but descriptive title for your PR. Explain what the PR adds, fixes, or improves. In case of bug fixes, add a new unit test case that would fail against your bug fix. Provide output or screenshots, if you can. Make sure your pull request passed all the CI checks (triggers automatically on pushing commits against dev branch) . If it's somehow failing, then ask the maintainer for a review. Click \"ready for review\" when finished. Test, Format & lint code locally: Make sure to test, format, and lint the modified code locally before every commit. The details are discussed below \u27b6 Make sensible commit messages: If your pull request fixes a separate issue number, remember to include \"resolves #issue_number\" in the commit message. Learn more about it here \u27b6 . Keep the commit message concisely as much as possible at every submit. You can make a supplement to the previous commit with git commit --amend command. Perform Integrity Checks: Any duplicate pull request will be Rejected! Search GitHub if there's a similar open or closed PR that relates to your submission. Check if your purpose code matches the overall direction, simplicity, and structure of the DeFFcode and improves it. Retain copyright for your contributions, but also agree to license them for usage by the project and author(s) under the Apache 2.0 license \u27b6 . Link your Issues: For more information on Linking a pull request to an issue, See this wiki doc\u27b6 Finally, when you're confident enough, make your pull request public. You can link an issue to a pull request manually or using a supported keyword in the pull request description. It helps collaborators see that someone is working on the issue.","title":"PR Submission Checklist"},{"location":"contribution/PR/#testing-formatting-linting","text":"All Pull Request(s) must be tested, formatted & linted against our library standards as discussed below:","title":"Testing, Formatting &amp; Linting"},{"location":"contribution/PR/#requirements","text":"Testing DeFFcode requires additional test dependencies and dataset, which can be handled manually as follows: Install additional python libraries: You can easily install these dependencies via pip: # Install opencv(only if not installed previously) pip install opencv-python # install rest of dependencies pip install --upgrade flake8 black pytest vidgear [ core ] Download Tests Dataset: To perform tests, you also need to download additional dataset (to your temp dir) by running prepare_dataset.sh bash script as follows: # On linux or macOS chmod +x scripts/bash/prepare_dataset.sh ./scripts/bash/prepare_dataset.sh # On Windows sh scripts/bash/prepare_dataset.sh","title":"Requirements"},{"location":"contribution/PR/#running-tests","text":"All tests can be run with pytest ( in DeFFcode's root folder ) as follows: pytest -sv #-sv for verbose output.","title":"Running Tests"},{"location":"contribution/PR/#formatting-linting","text":"For formatting and linting, following libraries are used: Flake8: You must run flake8 linting for checking the code base against the coding style (PEP8), programming errors and other cyclomatic complexity: flake8 { source_file_or_directory } --count --select = E9,F63,F7,F82 --show-source --statistics Black: DeFFcode follows black formatting to make code review faster by producing the smallest diffs possible. You must run it with sensible defaults as follows: black { source_file_or_directory }","title":"Formatting &amp; Linting"},{"location":"contribution/PR/#frequently-asked-questions","text":"Q1. Why do my changes taking so long to be Reviewed and/or Merged? Submission Aftermaths After your PR is merged, you can safely delete your branch and pull the changes from the main (upstream) repository. The changes will remain in dev branch until next DeFFcode version is released, then it will be merged into master branch. After a successful Merge, your newer contributions will be given priority over others. Pull requests will be reviewed by the maintainers and the rationale behind the maintainer\u2019s decision to accept or deny the changes will be posted in the pull request. Please wait for our code review and approval, possibly enhancing your change on request. Q2. Would you accept a huge Pull Request with Lots of Changes? First, make sure that the changes are somewhat related. Otherwise, please create separate pull requests. Anyway, before submitting a huge change, it's probably a good idea to open an issue in the DeFFcode Github repository to ask the maintainers if they agree with your proposed changes. Otherwise, they could refuse your proposal after you put all that hard work into making the changes. We definitely don't want you to waste your time!","title":"Frequently Asked Questions"},{"location":"contribution/issue/","text":"Submitting an Issue Guidelines \u00b6 If you've found a new bug or you've come up with some new feature which can improve the quality of the DeFFcode, then related issues are welcomed! But, Before you do, please read the following guidelines: First Issue on GitHub? You can easily learn about it from creating an issue wiki. Info Please note that your issue will be fixed much faster if you spend about half an hour preparing it, including the exact reproduction steps and a demo. If you're in a hurry or don't feel confident, it's fine to report issues with less details, but this makes it less likely they'll get fixed soon. Search the Docs and Previous Issues \u00b6 Remember to first search GitHub for a open or closed issue that relates to your submission or already been reported. You may find related information and the discussion might inform you of workarounds that may help to resolve the issue. For quick questions, please refrain from opening an issue, as you can reach us on Gitter community channel. Also, go comprehensively through our dedicated FAQ & Troubleshooting section . Gather Required Information \u00b6 All DeFFcode APIs provides a verbose boolean flag in parameters, to log debugged output to terminal. Kindly turn this parameter True in the respective API for getting debug output, and paste it with your Issue. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction code for your report. Check and paste, exact DeFFcode version by running command python - c \"import deffcode; print(deffcode.__version__)\" . Follow the Issue Template \u00b6 Please format your issue by choosing the appropriate template. Any improper/insufficient reports will be marked invalid , and if we don't hear back from you we may close the issue. Raise the Issue \u00b6 Add a brief but descriptive title for your issue. Keep the issue phrasing in context of the problem. Attach source-code/screenshots if you have one. Finally, raise it by choosing the appropriate Issue Template: Bug report , Proposal , Question .","title":"Issue Guidelines"},{"location":"contribution/issue/#submitting-an-issue-guidelines","text":"If you've found a new bug or you've come up with some new feature which can improve the quality of the DeFFcode, then related issues are welcomed! But, Before you do, please read the following guidelines: First Issue on GitHub? You can easily learn about it from creating an issue wiki. Info Please note that your issue will be fixed much faster if you spend about half an hour preparing it, including the exact reproduction steps and a demo. If you're in a hurry or don't feel confident, it's fine to report issues with less details, but this makes it less likely they'll get fixed soon.","title":"Submitting an Issue Guidelines"},{"location":"contribution/issue/#search-the-docs-and-previous-issues","text":"Remember to first search GitHub for a open or closed issue that relates to your submission or already been reported. You may find related information and the discussion might inform you of workarounds that may help to resolve the issue. For quick questions, please refrain from opening an issue, as you can reach us on Gitter community channel. Also, go comprehensively through our dedicated FAQ & Troubleshooting section .","title":"Search the Docs and Previous Issues"},{"location":"contribution/issue/#gather-required-information","text":"All DeFFcode APIs provides a verbose boolean flag in parameters, to log debugged output to terminal. Kindly turn this parameter True in the respective API for getting debug output, and paste it with your Issue. In order to reproduce bugs we will systematically ask you to provide a minimal reproduction code for your report. Check and paste, exact DeFFcode version by running command python - c \"import deffcode; print(deffcode.__version__)\" .","title":"Gather Required Information"},{"location":"contribution/issue/#follow-the-issue-template","text":"Please format your issue by choosing the appropriate template. Any improper/insufficient reports will be marked invalid , and if we don't hear back from you we may close the issue.","title":"Follow the Issue Template"},{"location":"contribution/issue/#raise-the-issue","text":"Add a brief but descriptive title for your issue. Keep the issue phrasing in context of the problem. Attach source-code/screenshots if you have one. Finally, raise it by choosing the appropriate Issue Template: Bug report , Proposal , Question .","title":"Raise the Issue"},{"location":"examples/advanced/","text":"Advanced Recipes \u00b6 This is a continuation of the Basic Recipes \u27b6 . Thereby, It's advised to first read through that before reading through this documentation. Important Information DeFFcode APIs MUST requires FFmpeg executable present in path. Follow these dedicated Installation Instructions \u27b6 for its installation. All DeFFcode APIs will raise RuntimeError if they fails to detect valid FFmpeg executable on your system! Always use terminate() function at the end with FFdecoder API to avoid undesired behavior. \u2009 Generating Video with Complex Filter Applied \u00b6 FFdecoder API also provides extensive support for FFmpeg's Video Filter through -filter_complex FFmpeg parameter to its real-time generated frames, thereby lets you build a Complex Filtergraph , applying different filter chains to different inputs and using their outputs as inputs for other filter chains. In this example we will apply a Custom Watermark Image( \"watermark.png\" ) Overlay with additional Video Filter definitions to real-time frames in FFdecoder API through -filter_complex FFmpeg parameter, and generate output video using OpenCV Library's VideoWriter() class. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. To learn about exclusive -clones parameter. See Exclusive Parameters \u27b6 # import the necessary packages from deffcode import FFdecoder import json , cv2 # define the Complex Video Filter with additional `watermark.png` image input extraparams = { \"-clones\" : [ \"-i\" , \"watermark.png\" ], # define your `watermark.png` here \"-filter_complex\" : \"[1]format=rgba,colorchannelmixer=aa=0.5[logo];[0][logo]overlay=W-w-5:H-h-5:format=auto,format=bgr24\" } # initialize and formulate the decoder for BGR24 output with given params decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release () Generating Video from Image sequence \u00b6 FFdecoder API provides out-of-the-box support for image sequence such as Sequential( 'img%03d.png' ), Glob pattern( '*.png' ), and even Single(looping) image as input to its source parameter. In this example we will generate grayscale video from Image Sequence using FFdecoder(Decoder), and generate output video using OpenCV Library's VideoWriter() class. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. Extracting Image Sequence from a video You can use following command to extract frames from a given video: ffmpeg -i foo.mp4 image-%03d.png This will extract 25 images per second from the file video.webm and save them as image-000.png , image-001.png , image-002.png up to image-999.png . If there are more than 1000 frames then the last image will be overwritten with the remaining frames leaving only the last frame. The encoding of the images and of the video is inferred from the extensions. The framerate is 25 fps by default. The images width and height is taken from the video. Extract one image per second: ffmpeg -i video.webm -framerate 1 image-%03d.png # To learn about exclusive -ffprefixes parameter. See Exclusive Parameters \u27b6 Sequential Glob pattern Single image(looping) Start with specific number image You can use -start_number FFmpeg parameter if you want to start with specific number image: # define `-start_number` such as `5` extraparams = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img %03d .png' , verbose = True , ** extraparams ) . formulate () # import the necessary packages from deffcode import FFdecoder import cv2 , json # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"/path/to/pngs/img %03d .png\" , frame_format = \"bgr24\" , verbose = True ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. The glob pattern is not available on Windows FFmpeg builds. # import the necessary packages from deffcode import FFdecoder import cv2 , json # define `-pattern_type glob` for accepting glob pattern extraparams = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"/path/to/pngs/img*.png\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo_gray.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the GRAYSCALE frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # lets convert frame to gray for this case gray = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2GRAY ) # writing GRAYSCALE frame to writer writer . write ( gray ) # terminate the decoder decoder . terminate () # safely close writer writer . close () You can use a single looping image as follows: # import the necessary packages from deffcode import FFdecoder import cv2 , json # define `-loop 1` for looping extraparams = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"img.png\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = 25.0 FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release () Generating Lossless Video using VidGear Library \u00b6 WriteGear's FFmpeg support for FFdecoder API is still in beta and can cause very high CPU usage. Kindly use OpenCV's VideoWriter Class until this issue is resolved. Reasons to use VidGear and its WriteGear API? VidGear is a cross-platform High-Performance Video-Processing Framework for building complex real-time media applications in python \ud83d\udd25 VidGear with its WriteGear API implements a complete, flexible, and robust wrapper around FFmpeg in compression mode that can process real-time NumPy frames into a lossless compressed video-files. DeFFcode's FFdecoder with WriteGear API creates powerful high-level FFmpeg Transcoding(Decoding + Encoding) Pipeline that provide us the freedom to do almost anything imaginable with multimedia data in real-time. FFdecoder is designed exclusively to work seamlessly with WriteGear API for encoding lossless compressed video-file with any suitable specifications (such as bitrate, codec, framerate, resolution, subtitles, etc.) . In this example we will generate lossless video with controlled framerate: You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate. Default BGR format in WriteGear API WriteGear API by default expects BGR format frames in its write(frame) function. However you can use rgb_mode boolean parameter for RGB Mode , which when enabled (i.e. rgb_mode=True ) , makes WriteGear API accept frames of RGB format instead. Save \"BGR\" Video Save \"RGB\" Video Save \"GRAYSCALE\" Video # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` # parameter for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo.mp4` writer = WriteGear ( output_filename = \"output_foo.mp4\" , ** output_params ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . close () Use rgb_mode boolean parameter to write RGB24 format in WriteGear API. # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder decoder = FFdecoder ( \"input_foo.mp4\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` # parameter for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo.mp4` writer = WriteGear ( output_filename = \"output_foo.mp4\" , ** output_params ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing RGB24 frame to writer writer . write ( frame , rgb_mode = True ) # terminate the decoder decoder . terminate () # safely close writer writer . close () # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder for GRAYSCALE output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"gray\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` parameter # for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo_gray.mp4` writer = WriteGear ( output_filename = \"output_foo_gray.mp4\" , ** output_params ) # grab the GRAYSCALE frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing GRAYSCALE frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . close () GPU enabled Hardware-Accelerated Decoding \u00b6 By default, FFdecoder API uses Source Video's decoder (extracted using Sourcer API) for decoding input. But you can easily change it to your suitable supported decoder through -vcodec FFmpeg parameter by passing it as an attribute with FFdecoder's extraparams dictionary parameter. In addition to this, you can also specify the additional properties/features of your system's GPU easily. User Discretion Advised This example is just conveying the idea on how to use FFmpeg's hardware decoders with FFdecoder API, which MAY/MAY NOT suit your system. Kindly use suitable parameters based your system hardware settings only. In this example, we will be using NVIDIA's CUVID \"h264_cuvid\" as our hardware decoder and also optionally be specifying other features such as \u2013hwaccel cuvid and filters like -vf \"fade,hwupload_cuda,scale_npp=1280:720\" . Thereby displaying the output frames with OpenCV's imshow() : More information on NVIDIA's CUVID can be found here \u27b6 Remember to check NVIDIA's CUVID support in FFmpeg To use h264_cuvid decoder, remember to check if its available and your FFmpeg compiled with CUVID support. You can easily do this by executing following one-liner command in your terminal, and observing if output contains something similar as follows: ffmpeg -hide_banner -encoders | grep h264 VFS..D h264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 V....D h264_qsv H264 video ( Intel Quick Sync Video acceleration ) ( codec h264 ) V..... h264_cuvid Nvidia CUVID H264 decoder ( codec h264 ) To learn about exclusive -ffprefixes and -ffpostfixes parameters. See Exclusive Parameters \u27b6 # import the necessary packages from deffcode import FFdecoder import cv2 # define suitable FFmpeg parameter extraparams = { \"-vcodec\" : \"h264_cuvid\" , \"-ffprefixes\" : [ \"\u2013hwaccel\" , \"cuvid\" ], \"-ffpostfixes\" : [ \"-vf\" , \"fade,hwupload_cuda,scale_npp=1280:720\" ], } # initialize and formulate the decode with suitable source and params decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate ()","title":"Advanced Recipies"},{"location":"examples/advanced/#advanced-recipes","text":"This is a continuation of the Basic Recipes \u27b6 . Thereby, It's advised to first read through that before reading through this documentation. Important Information DeFFcode APIs MUST requires FFmpeg executable present in path. Follow these dedicated Installation Instructions \u27b6 for its installation. All DeFFcode APIs will raise RuntimeError if they fails to detect valid FFmpeg executable on your system! Always use terminate() function at the end with FFdecoder API to avoid undesired behavior.","title":"Advanced Recipes"},{"location":"examples/advanced/#generating-video-with-complex-filter-applied","text":"FFdecoder API also provides extensive support for FFmpeg's Video Filter through -filter_complex FFmpeg parameter to its real-time generated frames, thereby lets you build a Complex Filtergraph , applying different filter chains to different inputs and using their outputs as inputs for other filter chains. In this example we will apply a Custom Watermark Image( \"watermark.png\" ) Overlay with additional Video Filter definitions to real-time frames in FFdecoder API through -filter_complex FFmpeg parameter, and generate output video using OpenCV Library's VideoWriter() class. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. To learn about exclusive -clones parameter. See Exclusive Parameters \u27b6 # import the necessary packages from deffcode import FFdecoder import json , cv2 # define the Complex Video Filter with additional `watermark.png` image input extraparams = { \"-clones\" : [ \"-i\" , \"watermark.png\" ], # define your `watermark.png` here \"-filter_complex\" : \"[1]format=rgba,colorchannelmixer=aa=0.5[logo];[0][logo]overlay=W-w-5:H-h-5:format=auto,format=bgr24\" } # initialize and formulate the decoder for BGR24 output with given params decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release ()","title":"Generating Video with Complex Filter Applied"},{"location":"examples/advanced/#generating-video-from-image-sequence","text":"FFdecoder API provides out-of-the-box support for image sequence such as Sequential( 'img%03d.png' ), Glob pattern( '*.png' ), and even Single(looping) image as input to its source parameter. In this example we will generate grayscale video from Image Sequence using FFdecoder(Decoder), and generate output video using OpenCV Library's VideoWriter() class. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. Extracting Image Sequence from a video You can use following command to extract frames from a given video: ffmpeg -i foo.mp4 image-%03d.png This will extract 25 images per second from the file video.webm and save them as image-000.png , image-001.png , image-002.png up to image-999.png . If there are more than 1000 frames then the last image will be overwritten with the remaining frames leaving only the last frame. The encoding of the images and of the video is inferred from the extensions. The framerate is 25 fps by default. The images width and height is taken from the video. Extract one image per second: ffmpeg -i video.webm -framerate 1 image-%03d.png # To learn about exclusive -ffprefixes parameter. See Exclusive Parameters \u27b6 Sequential Glob pattern Single image(looping) Start with specific number image You can use -start_number FFmpeg parameter if you want to start with specific number image: # define `-start_number` such as `5` extraparams = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img %03d .png' , verbose = True , ** extraparams ) . formulate () # import the necessary packages from deffcode import FFdecoder import cv2 , json # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"/path/to/pngs/img %03d .png\" , frame_format = \"bgr24\" , verbose = True ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. The glob pattern is not available on Windows FFmpeg builds. # import the necessary packages from deffcode import FFdecoder import cv2 , json # define `-pattern_type glob` for accepting glob pattern extraparams = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"/path/to/pngs/img*.png\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo_gray.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the GRAYSCALE frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # lets convert frame to gray for this case gray = cv2 . cvtColor ( frame , cv2 . COLOR_BGR2GRAY ) # writing GRAYSCALE frame to writer writer . write ( gray ) # terminate the decoder decoder . terminate () # safely close writer writer . close () You can use a single looping image as follows: # import the necessary packages from deffcode import FFdecoder import cv2 , json # define `-loop 1` for looping extraparams = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"img.png\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = 25.0 FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release ()","title":"Generating Video from Image sequence"},{"location":"examples/advanced/#generating-lossless-video-using-vidgear-library","text":"WriteGear's FFmpeg support for FFdecoder API is still in beta and can cause very high CPU usage. Kindly use OpenCV's VideoWriter Class until this issue is resolved. Reasons to use VidGear and its WriteGear API? VidGear is a cross-platform High-Performance Video-Processing Framework for building complex real-time media applications in python \ud83d\udd25 VidGear with its WriteGear API implements a complete, flexible, and robust wrapper around FFmpeg in compression mode that can process real-time NumPy frames into a lossless compressed video-files. DeFFcode's FFdecoder with WriteGear API creates powerful high-level FFmpeg Transcoding(Decoding + Encoding) Pipeline that provide us the freedom to do almost anything imaginable with multimedia data in real-time. FFdecoder is designed exclusively to work seamlessly with WriteGear API for encoding lossless compressed video-file with any suitable specifications (such as bitrate, codec, framerate, resolution, subtitles, etc.) . In this example we will generate lossless video with controlled framerate: You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate. Default BGR format in WriteGear API WriteGear API by default expects BGR format frames in its write(frame) function. However you can use rgb_mode boolean parameter for RGB Mode , which when enabled (i.e. rgb_mode=True ) , makes WriteGear API accept frames of RGB format instead. Save \"BGR\" Video Save \"RGB\" Video Save \"GRAYSCALE\" Video # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` # parameter for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo.mp4` writer = WriteGear ( output_filename = \"output_foo.mp4\" , ** output_params ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . close () Use rgb_mode boolean parameter to write RGB24 format in WriteGear API. # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder decoder = FFdecoder ( \"input_foo.mp4\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` # parameter for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo.mp4` writer = WriteGear ( output_filename = \"output_foo.mp4\" , ** output_params ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing RGB24 frame to writer writer . write ( frame , rgb_mode = True ) # terminate the decoder decoder . terminate () # safely close writer writer . close () # import the necessary packages from deffcode import FFdecoder from vidgear.gears import WriteGear import json # initialize and formulate the decoder for GRAYSCALE output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"gray\" , verbose = True ) . formulate () # retrieve framerate from source JSON Metadata and pass it as `-input_framerate` parameter # for controlled output framerate output_params = { \"-input_framerate\" : json . loads ( decoder . metadata )[ \"source_video_framerate\" ] } # Define writer with default parameters and suitable # output filename for e.g. `output_foo_gray.mp4` writer = WriteGear ( output_filename = \"output_foo_gray.mp4\" , ** output_params ) # grab the GRAYSCALE frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing GRAYSCALE frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . close ()","title":"Generating Lossless Video using VidGear Library"},{"location":"examples/advanced/#gpu-enabled-hardware-accelerated-decoding","text":"By default, FFdecoder API uses Source Video's decoder (extracted using Sourcer API) for decoding input. But you can easily change it to your suitable supported decoder through -vcodec FFmpeg parameter by passing it as an attribute with FFdecoder's extraparams dictionary parameter. In addition to this, you can also specify the additional properties/features of your system's GPU easily. User Discretion Advised This example is just conveying the idea on how to use FFmpeg's hardware decoders with FFdecoder API, which MAY/MAY NOT suit your system. Kindly use suitable parameters based your system hardware settings only. In this example, we will be using NVIDIA's CUVID \"h264_cuvid\" as our hardware decoder and also optionally be specifying other features such as \u2013hwaccel cuvid and filters like -vf \"fade,hwupload_cuda,scale_npp=1280:720\" . Thereby displaying the output frames with OpenCV's imshow() : More information on NVIDIA's CUVID can be found here \u27b6 Remember to check NVIDIA's CUVID support in FFmpeg To use h264_cuvid decoder, remember to check if its available and your FFmpeg compiled with CUVID support. You can easily do this by executing following one-liner command in your terminal, and observing if output contains something similar as follows: ffmpeg -hide_banner -encoders | grep h264 VFS..D h264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10 V....D h264_qsv H264 video ( Intel Quick Sync Video acceleration ) ( codec h264 ) V..... h264_cuvid Nvidia CUVID H264 decoder ( codec h264 ) To learn about exclusive -ffprefixes and -ffpostfixes parameters. See Exclusive Parameters \u27b6 # import the necessary packages from deffcode import FFdecoder import cv2 # define suitable FFmpeg parameter extraparams = { \"-vcodec\" : \"h264_cuvid\" , \"-ffprefixes\" : [ \"\u2013hwaccel\" , \"cuvid\" ], \"-ffpostfixes\" : [ \"-vf\" , \"fade,hwupload_cuda,scale_npp=1280:720\" ], } # initialize and formulate the decode with suitable source and params decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" , verbose = True , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate ()","title":"GPU enabled Hardware-Accelerated Decoding"},{"location":"examples/basic/","text":"Basic Recipes \u00b6 Important Information DeFFcode APIs MUST requires FFmpeg executable present in path. Follow these dedicated Installation Instructions \u27b6 for its installation. All DeFFcode APIs will raise RuntimeError if they fails to detect valid FFmpeg executable on your system! Always use terminate() function at the end with FFdecoder API to avoid undesired behavior. \u2009 Saving Keyframes as Image \u00b6 In Python, there are many libraries available in Python that allow us to store ndarray frames as images. And in combination with DeFFcode's effortless and precise FFmpeg Frame Seeking with -ss parameter, we can save any frame from a specific part of our input source. Here's a example for seeking to 00:00:01.45 (or 1045msec) in time, and get one single frame, thereby saving it as JPEG image with few prominent python libraries. Time unit syntax in -ss FFmpeg parameter You can use two different time unit formats with -ss FFmpeg parameter: Sexagesimal(in seconds): Uses (HOURS:MM:SS.MILLISECONDS) , such as in 01:23:45.678 Fractional: such as in 02:30.05 , this is interpreted as 2 minutes, 30 seconds, and a half a second, which would be the same as using 150.5 in seconds. Using Pillow Using OpenCV Using Matplotlib Using imageio In Pillow, the fromarray() function is used to create an image memory from an RGB array. We can then save this image memory to our desired location by providing the required path and the filename as follows: # import the necessary packages from deffcode import FFdecoder from PIL import Image # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Convert and save our output im = Image . fromarray ( frame ) im . save ( \"filename.jpeg\" ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In OpenCV, the imwrite() function can export only BGR frames as an image file, thereby make sure to use frame_format=\"bgr24\" as shown below: # import the necessary packages from deffcode import FFdecoder import cv2 # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decoder for BGR24 outputwith suitable source decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" , ** extraparams ) . formulate () # grab the BGR24 frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output cv2 . imwrite ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In Matplotlib, the imsave() function can save an RGB frames as an image file: # import the necessary packages from deffcode import FFdecoder import matplotlib.pyplot as plt # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output plt . imsave ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In imageio, the imwrite() function is used to create an image memory from an RGB array: # import the necessary packages from deffcode import FFdecoder import imageio # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output imageio . imwrite ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () Display frames using OpenCV Library \u00b6 You can easily use DeFFcode APIs directly with any Video Processing library such OpenCV. In following example we're using OpenCV's imshow() to display real-time BGR frame from DeFFcode's FFdecoder API. FFdecoder API's generateFrame() function can be used both as a Generator and Iterator. But Generator is the recommended way. Use waitKey(1) after imshow() function While displaying frames with imshow() function, it is appropriate to set the time delay in waitKey() to 1msec to pause each frame in the video so that the thread is freed up to do the processing we want to do. In rare cases, when the playback needs to be at a certain framerate, we may want the delay to be higher than 1msec. As a Generator(Recommended) As a Iterator # import the necessary packages from deffcode import FFdecoder import cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # grab the RGB24(default) frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate () We can also use generateFrame() function as Iterator which is more close to OpenCV-Python (Python API for OpenCV) coding syntax: # import the necessary packages from deffcode import FFdecoder import cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # loop over frames while True : # grab the BGR24 frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate () Generate Source Video Metadata \u00b6 FFdecoder using its metadata property object (as Pretty JSON( json.dump )) , and Sourcer using its retrieve_metadata() method (as Python dictionary) , both DeFFcode APIs can be used for Source Metadata Extraction that extracts metadata out of given media file. In this example we will generate all metadata parameters available within foo.mp4 media file using both APIs. Using FFdecoder API Using Sourcer API # import the necessary packages from deffcode import FFdecoder # initialize and formulate the decoder using suitable source decoder = FFdecoder ( \"foo.mp4\" ) . formulate () # print metadata as `json.dump` print ( decoder . metadata ) # terminate the decoder decoder . terminate () After running above python code, the resultant Terminal Output will look something as following on Windows machine: { \"ffmpeg_binary_path\" : \"C:\\\\Users\\\\foo\\\\AppData\\\\Local\\\\Temp\\\\ffmpeg-static-win64-gpl/bin/ffmpeg.exe\" , \"source\" : \"foo.mp4\" , \"source_extension\" : \".mp4\" , \"source_video_resolution\" : [ 1280 , 720 ], \"source_video_framerate\" : 25.0 , \"source_video_pixfmt\" : \"yuv420p\" , \"source_video_decoder\" : \"h264\" , \"source_duration_sec\" : 5.31 , \"approx_video_nframes\" : 133 , \"source_video_bitrate\" : \"1205k\" , \"source_audio_bitrate\" : \"384k\" , \"source_audio_samplerate\" : \"48000 Hz\" , \"source_has_video\" : true , \"source_has_audio\" : true , \"source_has_image_sequence\" : false , \"ffdecoder_operational_mode\" : \"Video-Only\" } # import the necessary packages from deffcode import Sourcer # initialize and formulate the decoder using suitable source sourcer = Sourcer ( \"foo.mp4\" ) . probe_stream () # print metadata as `dict` print ( sourcer . retrieve_metadata ()) After running above python code, the resultant Terminal Output will look something as following on Windows machine: { 'ffmpeg_binary_path' : 'C: \\\\ Users \\\\ foo \\\\ AppData \\\\ Local \\\\ Temp \\\\ ffmpeg-static-win64-gpl/bin/ffmpeg.exe' , 'source' : 'foo.mp4' , 'source_extension' : '.mp4' , 'source_video_resolution' : [ 1280 , 720 ], 'source_video_framerate' : 25.0 , 'source_video_pixfmt' : 'yuv420p' , 'source_video_decoder' : 'h264' , 'source_duration_sec' : 5.31 , 'approx_video_nframes' : 133 , 'source_video_bitrate' : '1205k' , 'source_audio_bitrate' : '384k' , 'source_audio_samplerate' : '48000 Hz' , 'source_has_video' : True , 'source_has_audio' : True , 'source_has_image_sequence' : False } Generating Video from frames using OpenCV Library \u00b6 FFdecoder can work effortlessly with any OpenCV API class or method such as VideoWriter() to save the video. In this example we will generate video from FFdecoder outputted frames using OpenCV Library's VideoWriter() class which require a valid output filename (e.g. output.avi) , a FourCC code, output framerate, and lastly input frame-size. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects only BGR format frames in its write(frame) function. # import the necessary packages from deffcode import FFdecoder import json , cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release () Generating Video with Filter Applied \u00b6 FFdecoder API support almost any FFmpeg's Video Filter through -vf FFmpeg parameter that applies a single chain of filters to the to real-time generated frames. In this example we will apply Video Filter definitions (like rotate and drawtext ) to real-time frames in FFdecoder API through -vf FFmpeg parameter, and generate output video using OpenCV Library's VideoWriter() class. This example assumes you're running Windows machine. If not, then change fontfile path in drawtext Video Filter definition accordingly. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. # import the necessary packages from deffcode import FFdecoder import json , cv2 # define the Video Filter definition like `rotate` and `drawtext` with `-vf` FFmpeg parameter extraparams = { \"-vf\" : \"\" + \"rotate=angle=-20*PI/180:fillcolor=brown\" # rotate filter + \", \" + \"drawtext=text='Rotated Video':fontfile='c\\:\\/windows\\/fonts\\/arial.ttf':x=(w-text_w)/2:y=(h-text_h)/2:fontsize=24:fontcolor=white\" # drawtext filter } # initialize and formulate the decoder for BGR24 output with given params decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release ()","title":"Basic Recipies"},{"location":"examples/basic/#basic-recipes","text":"Important Information DeFFcode APIs MUST requires FFmpeg executable present in path. Follow these dedicated Installation Instructions \u27b6 for its installation. All DeFFcode APIs will raise RuntimeError if they fails to detect valid FFmpeg executable on your system! Always use terminate() function at the end with FFdecoder API to avoid undesired behavior.","title":"Basic Recipes"},{"location":"examples/basic/#saving-keyframes-as-image","text":"In Python, there are many libraries available in Python that allow us to store ndarray frames as images. And in combination with DeFFcode's effortless and precise FFmpeg Frame Seeking with -ss parameter, we can save any frame from a specific part of our input source. Here's a example for seeking to 00:00:01.45 (or 1045msec) in time, and get one single frame, thereby saving it as JPEG image with few prominent python libraries. Time unit syntax in -ss FFmpeg parameter You can use two different time unit formats with -ss FFmpeg parameter: Sexagesimal(in seconds): Uses (HOURS:MM:SS.MILLISECONDS) , such as in 01:23:45.678 Fractional: such as in 02:30.05 , this is interpreted as 2 minutes, 30 seconds, and a half a second, which would be the same as using 150.5 in seconds. Using Pillow Using OpenCV Using Matplotlib Using imageio In Pillow, the fromarray() function is used to create an image memory from an RGB array. We can then save this image memory to our desired location by providing the required path and the filename as follows: # import the necessary packages from deffcode import FFdecoder from PIL import Image # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Convert and save our output im = Image . fromarray ( frame ) im . save ( \"filename.jpeg\" ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In OpenCV, the imwrite() function can export only BGR frames as an image file, thereby make sure to use frame_format=\"bgr24\" as shown below: # import the necessary packages from deffcode import FFdecoder import cv2 # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decoder for BGR24 outputwith suitable source decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" , ** extraparams ) . formulate () # grab the BGR24 frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output cv2 . imwrite ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In Matplotlib, the imsave() function can save an RGB frames as an image file: # import the necessary packages from deffcode import FFdecoder import matplotlib.pyplot as plt # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output plt . imsave ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate () In imageio, the imwrite() function is used to create an image memory from an RGB array: # import the necessary packages from deffcode import FFdecoder import imageio # define the FFmpeg parameter to seek to 00:00:01.45(or 1s and 45msec) # in time and get one single frame extraparams = { \"-ss\" : \"00:00:01.45\" , \"-frames:v\" : 1 } # initialize and formulate the decode with suitable source decoder = FFdecoder ( \"foo.mp4\" , ** extraparams ) . formulate () # grab the RGB24(default) frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if not ( frame is None ): # Save our output imageio . imwrite ( 'filename.jpeg' , frame ) else : print ( \"Something is wrong\" ) # terminate the decoder decoder . terminate ()","title":"Saving Keyframes as Image"},{"location":"examples/basic/#display-frames-using-opencv-library","text":"You can easily use DeFFcode APIs directly with any Video Processing library such OpenCV. In following example we're using OpenCV's imshow() to display real-time BGR frame from DeFFcode's FFdecoder API. FFdecoder API's generateFrame() function can be used both as a Generator and Iterator. But Generator is the recommended way. Use waitKey(1) after imshow() function While displaying frames with imshow() function, it is appropriate to set the time delay in waitKey() to 1msec to pause each frame in the video so that the thread is freed up to do the processing we want to do. In rare cases, when the playback needs to be at a certain framerate, we may want the delay to be higher than 1msec. As a Generator(Recommended) As a Iterator # import the necessary packages from deffcode import FFdecoder import cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # grab the RGB24(default) frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate () We can also use generateFrame() function as Iterator which is more close to OpenCV-Python (Python API for OpenCV) coding syntax: # import the necessary packages from deffcode import FFdecoder import cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # loop over frames while True : # grab the BGR24 frame from the decoder frame = next ( decoder . generateFrame (), None ) # check if frame is None if frame is None : break # Show output window cv2 . imshow ( \"Output\" , frame ) # check for 'q' key if pressed key = cv2 . waitKey ( 1 ) & 0xFF if key == ord ( \"q\" ): break # close output window cv2 . destroyAllWindows () # terminate the decoder decoder . terminate ()","title":"Display frames using OpenCV Library"},{"location":"examples/basic/#generate-source-video-metadata","text":"FFdecoder using its metadata property object (as Pretty JSON( json.dump )) , and Sourcer using its retrieve_metadata() method (as Python dictionary) , both DeFFcode APIs can be used for Source Metadata Extraction that extracts metadata out of given media file. In this example we will generate all metadata parameters available within foo.mp4 media file using both APIs. Using FFdecoder API Using Sourcer API # import the necessary packages from deffcode import FFdecoder # initialize and formulate the decoder using suitable source decoder = FFdecoder ( \"foo.mp4\" ) . formulate () # print metadata as `json.dump` print ( decoder . metadata ) # terminate the decoder decoder . terminate () After running above python code, the resultant Terminal Output will look something as following on Windows machine: { \"ffmpeg_binary_path\" : \"C:\\\\Users\\\\foo\\\\AppData\\\\Local\\\\Temp\\\\ffmpeg-static-win64-gpl/bin/ffmpeg.exe\" , \"source\" : \"foo.mp4\" , \"source_extension\" : \".mp4\" , \"source_video_resolution\" : [ 1280 , 720 ], \"source_video_framerate\" : 25.0 , \"source_video_pixfmt\" : \"yuv420p\" , \"source_video_decoder\" : \"h264\" , \"source_duration_sec\" : 5.31 , \"approx_video_nframes\" : 133 , \"source_video_bitrate\" : \"1205k\" , \"source_audio_bitrate\" : \"384k\" , \"source_audio_samplerate\" : \"48000 Hz\" , \"source_has_video\" : true , \"source_has_audio\" : true , \"source_has_image_sequence\" : false , \"ffdecoder_operational_mode\" : \"Video-Only\" } # import the necessary packages from deffcode import Sourcer # initialize and formulate the decoder using suitable source sourcer = Sourcer ( \"foo.mp4\" ) . probe_stream () # print metadata as `dict` print ( sourcer . retrieve_metadata ()) After running above python code, the resultant Terminal Output will look something as following on Windows machine: { 'ffmpeg_binary_path' : 'C: \\\\ Users \\\\ foo \\\\ AppData \\\\ Local \\\\ Temp \\\\ ffmpeg-static-win64-gpl/bin/ffmpeg.exe' , 'source' : 'foo.mp4' , 'source_extension' : '.mp4' , 'source_video_resolution' : [ 1280 , 720 ], 'source_video_framerate' : 25.0 , 'source_video_pixfmt' : 'yuv420p' , 'source_video_decoder' : 'h264' , 'source_duration_sec' : 5.31 , 'approx_video_nframes' : 133 , 'source_video_bitrate' : '1205k' , 'source_audio_bitrate' : '384k' , 'source_audio_samplerate' : '48000 Hz' , 'source_has_video' : True , 'source_has_audio' : True , 'source_has_image_sequence' : False }","title":"Generate Source Video Metadata"},{"location":"examples/basic/#generating-video-from-frames-using-opencv-library","text":"FFdecoder can work effortlessly with any OpenCV API class or method such as VideoWriter() to save the video. In this example we will generate video from FFdecoder outputted frames using OpenCV Library's VideoWriter() class which require a valid output filename (e.g. output.avi) , a FourCC code, output framerate, and lastly input frame-size. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects only BGR format frames in its write(frame) function. # import the necessary packages from deffcode import FFdecoder import json , cv2 # initialize and formulate the decoder for BGR24 output decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release ()","title":"Generating Video from frames using OpenCV Library"},{"location":"examples/basic/#generating-video-with-filter-applied","text":"FFdecoder API support almost any FFmpeg's Video Filter through -vf FFmpeg parameter that applies a single chain of filters to the to real-time generated frames. In this example we will apply Video Filter definitions (like rotate and drawtext ) to real-time frames in FFdecoder API through -vf FFmpeg parameter, and generate output video using OpenCV Library's VideoWriter() class. This example assumes you're running Windows machine. If not, then change fontfile path in drawtext Video Filter definition accordingly. You can use FFdecoder's metadata property object that dumps Source Metadata as JSON to retrieve source framerate and frame-size. OpenCV expects BGR format frames in its write(frame) function. # import the necessary packages from deffcode import FFdecoder import json , cv2 # define the Video Filter definition like `rotate` and `drawtext` with `-vf` FFmpeg parameter extraparams = { \"-vf\" : \"\" + \"rotate=angle=-20*PI/180:fillcolor=brown\" # rotate filter + \", \" + \"drawtext=text='Rotated Video':fontfile='c\\:\\/windows\\/fonts\\/arial.ttf':x=(w-text_w)/2:y=(h-text_h)/2:fontsize=24:fontcolor=white\" # drawtext filter } # initialize and formulate the decoder for BGR24 output with given params decoder = FFdecoder ( \"input_foo.mp4\" , frame_format = \"bgr24\" , ** extraparams ) . formulate () # retrieve JSON Metadata and convert it to dict metadata_dict = json . loads ( decoder . metadata ) # prepare OpenCV parameters FOURCC = cv2 . VideoWriter_fourcc ( \"M\" , \"J\" , \"P\" , \"G\" ) FRAMERATE = metadata_dict [ \"source_video_framerate\" ] FRAMESIZE = tuple ( metadata_dict [ \"source_video_resolution\" ]) # Define writer with parameters and suitable output filename for e.g. `output_foo.avi` writer = cv2 . VideoWriter ( \"output_foo.avi\" , FOURCC , FRAMERATE , FRAMESIZE ) # grab the BGR24 frame from the decoder for frame in decoder . generateFrame (): # check if frame is None if frame is None : break # {do something with the frame here} # writing BGR24 frame to writer writer . write ( frame ) # terminate the decoder decoder . terminate () # safely close writer writer . release ()","title":"Generating Video with Filter Applied"},{"location":"help/","text":"Help Us \u00b6 Liked DeFFcode? Would you like to help DeFFcode, other users, and the author? There are very simple ways to help us: Star DeFFcode on GitHub \u00b6 You can star DeFFcode on GitHub: It helps us a lot by making it easier for others to find & trust this library. Thanks! \u2009 Help others with issues on GitHub \u00b6 You can see through any opened or pinned existing issues on our GitHub repository, and try helping others, wherever possible: \u2009 Watch the GitHub repository \u00b6 You can watch \ud83d\udc40 DeFFcode Activities on GitHub: When you watch a repository, you will be notified of all conversations for that repository, including when someone creates a new issue, or pushes a new pull request. You can try helping solving those issues, or give valuable feedback/review on new Pull Requests. \u2009 Tweet about DeFFcode \u00b6 Tweet about DeFFcode and Spread the word \ud83d\udde3: Tweet #deffcode Let others know how you are using DeFFcode and why you like it! \u2009 Helping Author \u00b6 Donations help keep DeFFcode's development alive and motivate me (as author) . It is (like all open source software) a labour of love and something I am doing with my own free time. If you would like to say thanks, please feel free to make a donation through ko-fi: kofiwidget2.init('Support Me on Ko-fi', '#eba100', 'W7W8WTYO');kofiwidget2.draw(); Thanks a million! \u2009 Connect with Author \u00b6 You can connect with me, the author \ud83d\udc4b: Follow author on GitHub: Follow author on Twitter: Follow @abhi_una12 Get in touch with author on Linkedin:","title":"Helping Us"},{"location":"help/#help-us","text":"Liked DeFFcode? Would you like to help DeFFcode, other users, and the author? There are very simple ways to help us:","title":"Help Us"},{"location":"help/#star-deffcode-on-github","text":"You can star DeFFcode on GitHub: It helps us a lot by making it easier for others to find & trust this library. Thanks!","title":" Star DeFFcode on GitHub"},{"location":"help/#help-others-with-issues-on-github","text":"You can see through any opened or pinned existing issues on our GitHub repository, and try helping others, wherever possible:","title":" Help others with issues on GitHub"},{"location":"help/#watch-the-github-repository","text":"You can watch \ud83d\udc40 DeFFcode Activities on GitHub: When you watch a repository, you will be notified of all conversations for that repository, including when someone creates a new issue, or pushes a new pull request. You can try helping solving those issues, or give valuable feedback/review on new Pull Requests.","title":" Watch the GitHub repository"},{"location":"help/#tweet-about-deffcode","text":"Tweet about DeFFcode and Spread the word \ud83d\udde3: Tweet #deffcode Let others know how you are using DeFFcode and why you like it!","title":" Tweet about DeFFcode"},{"location":"help/#helping-author","text":"Donations help keep DeFFcode's development alive and motivate me (as author) . It is (like all open source software) a labour of love and something I am doing with my own free time. If you would like to say thanks, please feel free to make a donation through ko-fi: kofiwidget2.init('Support Me on Ko-fi', '#eba100', 'W7W8WTYO');kofiwidget2.draw(); Thanks a million!","title":" Helping Author"},{"location":"help/#connect-with-author","text":"You can connect with me, the author \ud83d\udc4b: Follow author on GitHub: Follow author on Twitter: Follow @abhi_una12 Get in touch with author on Linkedin:","title":" Connect with Author"},{"location":"help/get_help/","text":"Getting Help \u00b6 Courtesy - tenor Would you like to get help with DeFFcode? There are several ways to get help with DeFFcode: Join our Gitter Community channel \u00b6 Have you come up with some new idea \ud83d\udca1 or looking for the fastest way troubleshoot your problems Join and chat on our Gitter Community channel: There you can ask quick questions, swiftly troubleshoot your problems, help others, share ideas & information, etc. \u2009 This is what you do when... \u00b6 Got a question or problem? Found a typo? Found a bug? Missing a feature/improvement? \u2009 Reporting an issues \u00b6 Want to report a bug? Suggest a new feature? Before you do, please read our guidelines \u27b6 \u2009 Preparing a Pull Request \u00b6 Interested in contributing to DeFFcode? Before you do, please read our guidelines \u27b6","title":"Getting Help"},{"location":"help/get_help/#getting-help","text":"Courtesy - tenor Would you like to get help with DeFFcode? There are several ways to get help with DeFFcode:","title":"Getting Help"},{"location":"help/get_help/#join-our-gitter-community-channel","text":"Have you come up with some new idea \ud83d\udca1 or looking for the fastest way troubleshoot your problems Join and chat on our Gitter Community channel: There you can ask quick questions, swiftly troubleshoot your problems, help others, share ideas & information, etc.","title":" Join our Gitter Community channel"},{"location":"help/get_help/#this-is-what-you-do-when","text":"Got a question or problem? Found a typo? Found a bug? Missing a feature/improvement?","title":" This is what you do when..."},{"location":"help/get_help/#reporting-an-issues","text":"Want to report a bug? Suggest a new feature? Before you do, please read our guidelines \u27b6","title":"Reporting an issues"},{"location":"help/get_help/#preparing-a-pull-request","text":"Interested in contributing to DeFFcode? Before you do, please read our guidelines \u27b6","title":"Preparing a Pull Request"},{"location":"installation/","text":"Installation Notes \u00b6 Supported Systems \u00b6 DeFFcode is well-tested and supported on the following systems(but not limited to), with python 3.7+ and pip installed: Upgrade your pip It strongly advised to upgrade to latest pip before installing deffcode to avoid any undesired installation error(s). There are two mechanisms to upgrade pip : pip ensurepip You can use existing pip to upgrade itself: Install pip if not present Download the script, from https://bootstrap.pypa.io/get-pip.py . Open a terminal/command prompt, cd to the folder containing the get-pip.py file and run: Linux/MacOS Windows python get-pip.py py get-pip.py More details about this script can be found in pypa/get-pip\u2019s README . Linux/MacOS Windows python -m pip install pip --upgrade py -m pip install pip --upgrade Python also comes with an ensurepip module 1 , which can easily upgrade/install pip in any Python environment. Linux/MacOS Windows python -m ensurepip --upgrade py -m ensurepip --upgrade Any Linux distro released in 2016 or later Windows 7 or later MacOS 10.12.6 (Sierra) or later \u2009 Supported Python legacies \u00b6 Python 3.7+ are only supported legacies for installing DeFFcode v0.1.0 and above. \u2009 Prerequisites \u00b6 When installing DeFFcode, FFmpeg is the only prerequisites you need to install manually, except on Windows : FFmpeg \u00b6 Must require FFmpeg binaries installed for all core functions. You easily install it by following this dedicated FFmpeg Installation doc Installation \u00b6 A. Install using pip (Recommended) \u00b6 Best option for easily getting stable DeFFcode installed. Installation is as simple as: Windows Installation If you are using Windows, some of the commands given below, may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: # Install latest stable release python -m pip install -U deffcode And, If you don't have the privileges to the directory you're installing package. Then use --user flag, that makes pip install packages in your home directory instead: # Install latest stable release python -m pip install --upgrade --user deffcode Or, If you're using py as alias for installed python, then: # Install latest stable release py -m pip install --upgrade --user deffcode # Install latest stable release pip install -U deffcode And you can also download its wheel ( .whl ) package from our repository's releases section, thereby can be installed as follows: # Install latest release pip install deffcode-0.2.0-py3-none-any.whl \u2009 B. Installation from Source \u00b6 Best option for trying latest patches(maybe experimental), forking for Pull Requests, or automatically installing all prerequisites(with a few exceptions). Beta Branch dev If you're looking for latest work-in-progress enhancements/bug-fixes, then you want to checkout our beta dev branch with the following commands: The beta dev branch at times can be very unstable or even unusable, User discretion is advised! # clone the repository and get inside git clone https://github.com/abhiTronix/deffcode.git && cd deffcode # checkout the dev beta branch git checkout dev # Install it pip install -U . Windows Installation If you are using Windows, some of the commands given below, may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: # Install latest beta branch python -m pip install -U . And, If you don't have the privileges to the directory you're installing package. Then use --user flag, that makes pip install packages in your home directory instead: # Install latest beta branch python -m pip install --upgrade --user . Or, If you're using py as alias for installed python, then: # Install latest beta branch py -m pip install --upgrade --user . # clone the repository and get inside git clone https://github.com/abhiTronix/deffcode.git && cd deffcode # Install it pip install -U . The ensurepip module is missing/disabled on Ubuntu. Use pip method only. \u21a9","title":"Introduction"},{"location":"installation/#installation-notes","text":"","title":"Installation Notes"},{"location":"installation/#supported-systems","text":"DeFFcode is well-tested and supported on the following systems(but not limited to), with python 3.7+ and pip installed: Upgrade your pip It strongly advised to upgrade to latest pip before installing deffcode to avoid any undesired installation error(s). There are two mechanisms to upgrade pip : pip ensurepip You can use existing pip to upgrade itself: Install pip if not present Download the script, from https://bootstrap.pypa.io/get-pip.py . Open a terminal/command prompt, cd to the folder containing the get-pip.py file and run: Linux/MacOS Windows python get-pip.py py get-pip.py More details about this script can be found in pypa/get-pip\u2019s README . Linux/MacOS Windows python -m pip install pip --upgrade py -m pip install pip --upgrade Python also comes with an ensurepip module 1 , which can easily upgrade/install pip in any Python environment. Linux/MacOS Windows python -m ensurepip --upgrade py -m ensurepip --upgrade Any Linux distro released in 2016 or later Windows 7 or later MacOS 10.12.6 (Sierra) or later","title":"Supported Systems"},{"location":"installation/#supported-python-legacies","text":"Python 3.7+ are only supported legacies for installing DeFFcode v0.1.0 and above.","title":"Supported Python legacies"},{"location":"installation/#prerequisites","text":"When installing DeFFcode, FFmpeg is the only prerequisites you need to install manually, except on Windows :","title":"Prerequisites"},{"location":"installation/#ffmpeg","text":"Must require FFmpeg binaries installed for all core functions. You easily install it by following this dedicated FFmpeg Installation doc","title":"FFmpeg"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#a-install-using-pip-recommended","text":"Best option for easily getting stable DeFFcode installed. Installation is as simple as: Windows Installation If you are using Windows, some of the commands given below, may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: # Install latest stable release python -m pip install -U deffcode And, If you don't have the privileges to the directory you're installing package. Then use --user flag, that makes pip install packages in your home directory instead: # Install latest stable release python -m pip install --upgrade --user deffcode Or, If you're using py as alias for installed python, then: # Install latest stable release py -m pip install --upgrade --user deffcode # Install latest stable release pip install -U deffcode And you can also download its wheel ( .whl ) package from our repository's releases section, thereby can be installed as follows: # Install latest release pip install deffcode-0.2.0-py3-none-any.whl","title":"A. Install using pip (Recommended)"},{"location":"installation/#b-installation-from-source","text":"Best option for trying latest patches(maybe experimental), forking for Pull Requests, or automatically installing all prerequisites(with a few exceptions). Beta Branch dev If you're looking for latest work-in-progress enhancements/bug-fixes, then you want to checkout our beta dev branch with the following commands: The beta dev branch at times can be very unstable or even unusable, User discretion is advised! # clone the repository and get inside git clone https://github.com/abhiTronix/deffcode.git && cd deffcode # checkout the dev beta branch git checkout dev # Install it pip install -U . Windows Installation If you are using Windows, some of the commands given below, may not work out-of-the-box. A quick solution may be to preface every Python command with python -m like this: # Install latest beta branch python -m pip install -U . And, If you don't have the privileges to the directory you're installing package. Then use --user flag, that makes pip install packages in your home directory instead: # Install latest beta branch python -m pip install --upgrade --user . Or, If you're using py as alias for installed python, then: # Install latest beta branch py -m pip install --upgrade --user . # clone the repository and get inside git clone https://github.com/abhiTronix/deffcode.git && cd deffcode # Install it pip install -U . The ensurepip module is missing/disabled on Ubuntu. Use pip method only. \u21a9","title":"B. Installation from Source"},{"location":"installation/ffmpeg_install/","text":"FFmpeg Installation Doc \u00b6 \u2009 DeFFcode must requires FFmpeg executables for all its core functions. You can following machine-specific instructions for its installation: DeFFcode APIs will throw RuntimeError , if they failed to detect valid FFmpeg executables on your system. Enable verbose ( verbose=True ) for debugging FFmpeg validation process. \u2009 Linux FFmpeg Installation \u00b6 All DeFFcode APIs supports Auto-Detection and Manual Configuration methods on a Linux machine: A. Auto-Detection \u00b6 This is a recommended approach on Linux Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-detect the required FFmpeg installed binaries through a validation test that employs subprocess python module on the Linux OS systems. Installation: You can install easily install official FFmpeg according to your Linux Distro by following this post \u27b6 B. Manual Configuration \u00b6 Download: You can also manually download the latest Linux Static Binaries( based on your machine arch(x86/x64) ) from the link below: Linux Static Binaries: http://johnvansickle.com/ffmpeg/ Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'ffmpeg/bin' ) or path of ffmpeg executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError ! Windows FFmpeg Installation \u00b6 DeFFcode APIs supports Auto-Installation and Manual Configuration methods on Windows systems. A. Auto-Installation \u00b6 This is a recommended approach on Windows Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-generate the required FFmpeg Static Binaries from our dedicated Github Server into the temporary directory(e.g. C:\\Temp ) of your machine on the Windows OS systems. Active Internet connection is required while downloading required FFmpeg Static Binaries from our dedicated Github Server. Warning The files downloaded to a temporary directory (e.g. C:\\TEMP ), may get erased if your machine shutdowns/restarts. You can also provide a custom save path for auto-downloading FFmpeg Static Binaries through -ffmpeg_download_path parameter. If binaries were found at the specified path, StreamGear automatically skips the auto-installation step. If the required FFmpeg static binary fails to download, extract, or validate during auto-installation, then DeFFcode APIs will exit with RuntimeError ! B. Manual Configuration \u00b6 Download: You can also manually download the latest Windows Static Binaries( based on your machine arch(x86/x64) ) from the link below: Windows Static Binaries: https://ffmpeg.org/download.html#build-windows Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'C:/foo/Downloads/ffmpeg/bin' ) or path of ffmpeg.exe executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError ! MacOS FFmpeg Installation \u00b6 DeFFcode APIs supports Auto-Detection and Manual Configuration methods on a macOS machine. A. Auto-Detection \u00b6 This is a recommended approach on MacOS Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-detect the required FFmpeg installed binaries through a validation test that employs subprocess python module on the MacOS systems. Installation: You can easily install FFmpeg on your macOS machine by following this tutorial \u27b6 B. Manual Configuration \u00b6 Download: You can also manually download the latest macOS Static Binaries( only x64 Binaries ) from the link below: MacOS Static Binaries: http://johnvansickle.com/ffmpeg/ Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'ffmpeg/bin' ) or path of ffmpeg executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError !","title":"FFmpeg Installation"},{"location":"installation/ffmpeg_install/#ffmpeg-installation-doc","text":"DeFFcode must requires FFmpeg executables for all its core functions. You can following machine-specific instructions for its installation: DeFFcode APIs will throw RuntimeError , if they failed to detect valid FFmpeg executables on your system. Enable verbose ( verbose=True ) for debugging FFmpeg validation process.","title":"FFmpeg Installation Doc"},{"location":"installation/ffmpeg_install/#linux-ffmpeg-installation","text":"All DeFFcode APIs supports Auto-Detection and Manual Configuration methods on a Linux machine:","title":" Linux FFmpeg Installation"},{"location":"installation/ffmpeg_install/#a-auto-detection","text":"This is a recommended approach on Linux Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-detect the required FFmpeg installed binaries through a validation test that employs subprocess python module on the Linux OS systems. Installation: You can install easily install official FFmpeg according to your Linux Distro by following this post \u27b6","title":"A. Auto-Detection"},{"location":"installation/ffmpeg_install/#b-manual-configuration","text":"Download: You can also manually download the latest Linux Static Binaries( based on your machine arch(x86/x64) ) from the link below: Linux Static Binaries: http://johnvansickle.com/ffmpeg/ Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'ffmpeg/bin' ) or path of ffmpeg executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError !","title":"B. Manual Configuration"},{"location":"installation/ffmpeg_install/#windows-ffmpeg-installation","text":"DeFFcode APIs supports Auto-Installation and Manual Configuration methods on Windows systems.","title":" Windows FFmpeg Installation"},{"location":"installation/ffmpeg_install/#a-auto-installation","text":"This is a recommended approach on Windows Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-generate the required FFmpeg Static Binaries from our dedicated Github Server into the temporary directory(e.g. C:\\Temp ) of your machine on the Windows OS systems. Active Internet connection is required while downloading required FFmpeg Static Binaries from our dedicated Github Server. Warning The files downloaded to a temporary directory (e.g. C:\\TEMP ), may get erased if your machine shutdowns/restarts. You can also provide a custom save path for auto-downloading FFmpeg Static Binaries through -ffmpeg_download_path parameter. If binaries were found at the specified path, StreamGear automatically skips the auto-installation step. If the required FFmpeg static binary fails to download, extract, or validate during auto-installation, then DeFFcode APIs will exit with RuntimeError !","title":"A. Auto-Installation"},{"location":"installation/ffmpeg_install/#b-manual-configuration_1","text":"Download: You can also manually download the latest Windows Static Binaries( based on your machine arch(x86/x64) ) from the link below: Windows Static Binaries: https://ffmpeg.org/download.html#build-windows Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'C:/foo/Downloads/ffmpeg/bin' ) or path of ffmpeg.exe executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError !","title":"B. Manual Configuration"},{"location":"installation/ffmpeg_install/#macos-ffmpeg-installation","text":"DeFFcode APIs supports Auto-Detection and Manual Configuration methods on a macOS machine.","title":" MacOS FFmpeg Installation"},{"location":"installation/ffmpeg_install/#a-auto-detection_1","text":"This is a recommended approach on MacOS Machines If DeFFcode APIs do not receive any input from the user on custom_ffmpeg parameter, then they try to auto-detect the required FFmpeg installed binaries through a validation test that employs subprocess python module on the MacOS systems. Installation: You can easily install FFmpeg on your macOS machine by following this tutorial \u27b6","title":"A. Auto-Detection"},{"location":"installation/ffmpeg_install/#b-manual-configuration_2","text":"Download: You can also manually download the latest macOS Static Binaries( only x64 Binaries ) from the link below: MacOS Static Binaries: http://johnvansickle.com/ffmpeg/ Assignment: Then, you can easily assign the custom path to the folder containing FFmpeg executables( for e.g 'ffmpeg/bin' ) or path of ffmpeg executable itself to the custom_ffmpeg parameter in the DeFFcode APIs. If binaries were not found at the manually specified path, DeFFcode APIs will throw RuntimeError !","title":"B. Manual Configuration"},{"location":"reference/ffhelper/","text":"get_valid_ffmpeg_path \u00b6 Validate the given FFmpeg path/binaries, and returns a valid FFmpeg executable path. Parameters: Name Type Description Default custom_ffmpeg string path to custom FFmpeg executables '' is_windows boolean is running on Windows OS? False ffmpeg_download_path string FFmpeg static binaries download location (Windows only) '' verbose bool enables verbose for its operations False Returns: A valid FFmpeg executable path string. Source code in deffcode/ffhelper.py def get_valid_ffmpeg_path ( custom_ffmpeg = \"\" , is_windows = False , ffmpeg_download_path = \"\" , verbose = False ): \"\"\" ## get_valid_ffmpeg_path Validate the given FFmpeg path/binaries, and returns a valid FFmpeg executable path. Parameters: custom_ffmpeg (string): path to custom FFmpeg executables is_windows (boolean): is running on Windows OS? ffmpeg_download_path (string): FFmpeg static binaries download location _(Windows only)_ verbose (bool): enables verbose for its operations **Returns:** A valid FFmpeg executable path string. \"\"\" final_path = \"\" if is_windows : # checks if current os is windows if custom_ffmpeg : # if custom FFmpeg path is given assign to local variable final_path += custom_ffmpeg else : # otherwise auto-download them try : if not ( ffmpeg_download_path ): # otherwise save to Temp Directory import tempfile ffmpeg_download_path = tempfile . gettempdir () verbose and logger . debug ( \"FFmpeg Windows Download Path: {} \" . format ( ffmpeg_download_path ) ) # download Binaries os_bit = ( ( \"win64\" if platform . machine () . endswith ( \"64\" ) else \"win32\" ) if is_windows else \"\" ) _path = download_ffmpeg_binaries ( path = ffmpeg_download_path , os_windows = is_windows , os_bit = os_bit ) # assign to local variable final_path += _path except Exception as e : # log if any error occurred logger . exception ( str ( e )) logger . error ( \"Error in downloading FFmpeg binaries, Check your network and Try again!\" ) return False if os . path . isfile ( final_path ): # check if valid FFmpeg file exist pass elif os . path . isfile ( os . path . join ( final_path , \"ffmpeg.exe\" )): # check if FFmpeg directory exists, if does, then check for valid file final_path = os . path . join ( final_path , \"ffmpeg.exe\" ) else : # else return False verbose and logger . debug ( \"No valid FFmpeg executables found at Custom FFmpeg path!\" ) return False else : # otherwise perform test for Unix if custom_ffmpeg : # if custom FFmpeg path is given assign to local variable if os . path . isfile ( custom_ffmpeg ): # check if valid FFmpeg file exist final_path += custom_ffmpeg elif os . path . isfile ( os . path . join ( custom_ffmpeg , \"ffmpeg\" )): # check if FFmpeg directory exists, if does, then check for valid file final_path = os . path . join ( custom_ffmpeg , \"ffmpeg\" ) else : # else return False verbose and logger . debug ( \"No valid FFmpeg executables found at Custom FFmpeg path!\" ) return False else : # otherwise assign ffmpeg binaries from system final_path += \"ffmpeg\" verbose and logger . debug ( \"Final FFmpeg Path: {} \" . format ( final_path )) # Final Auto-Validation for FFmeg Binaries. returns final path if test is passed return final_path if validate_ffmpeg ( final_path , verbose = verbose ) else False download_ffmpeg_binaries \u00b6 Generates FFmpeg Static Binaries for windows(if not available) Parameters: Name Type Description Default path string path for downloading custom FFmpeg executables required os_windows boolean is running on Windows OS? False os_bit string 32-bit or 64-bit OS? '' Returns: A valid FFmpeg executable path string. Source code in deffcode/ffhelper.py def download_ffmpeg_binaries ( path , os_windows = False , os_bit = \"\" ): \"\"\" ## download_ffmpeg_binaries Generates FFmpeg Static Binaries for windows(if not available) Parameters: path (string): path for downloading custom FFmpeg executables os_windows (boolean): is running on Windows OS? os_bit (string): 32-bit or 64-bit OS? **Returns:** A valid FFmpeg executable path string. \"\"\" final_path = \"\" if os_windows and os_bit : # initialize with available FFmpeg Static Binaries GitHub Server file_url = \"https://github.com/abhiTronix/FFmpeg-Builds/releases/latest/download/ffmpeg-static- {} -gpl.zip\" . format ( os_bit ) file_name = os . path . join ( os . path . abspath ( path ), \"ffmpeg-static- {} -gpl.zip\" . format ( os_bit ) ) file_path = os . path . join ( os . path . abspath ( path ), \"ffmpeg-static- {} -gpl/bin/ffmpeg.exe\" . format ( os_bit ), ) base_path , _ = os . path . split ( file_name ) # extract file base path # check if file already exists if os . path . isfile ( file_path ): final_path += file_path # skip download if does else : # import libs import zipfile # check if given path has write access assert os . access ( path , os . W_OK ), ( \"[Helper:ERROR] :: Permission Denied, Cannot write binaries to directory = \" + path ) # remove leftovers if exists os . path . isfile ( file_name ) and delete_file_safe ( file_name ) # download and write file to the given path with open ( file_name , \"wb\" ) as f : logger . debug ( \"No Custom FFmpeg path provided. Auto-Installing FFmpeg static binaries from GitHub Mirror now. Please wait...\" ) # create session with requests . Session () as http : # setup retry strategy retries = Retry ( total = 3 , backoff_factor = 1 , status_forcelist = [ 429 , 500 , 502 , 503 , 504 ], ) # Mount it for https usage adapter = TimeoutHTTPAdapter ( timeout = 2.0 , max_retries = retries ) http . mount ( \"https://\" , adapter ) response = http . get ( file_url , stream = True ) response . raise_for_status () total_length = response . headers . get ( \"content-length\" ) assert not ( total_length is None ), \"[Helper:ERROR] :: Failed to retrieve files, check your Internet connectivity!\" bar = tqdm ( total = int ( total_length ), unit = \"B\" , unit_scale = True ) for data in response . iter_content ( chunk_size = 4096 ): f . write ( data ) len ( data ) > 0 and bar . update ( len ( data )) bar . close () logger . debug ( \"Extracting executables.\" ) with zipfile . ZipFile ( file_name , \"r\" ) as zip_ref : zip_fname , _ = os . path . split ( zip_ref . infolist ()[ 0 ] . filename ) zip_ref . extractall ( base_path ) # perform cleaning delete_file_safe ( file_name ) logger . debug ( \"FFmpeg binaries for Windows configured successfully!\" ) final_path += file_path # return final path return final_path validate_ffmpeg \u00b6 Validate FFmeg Binaries. returns True if tests are passed. Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def validate_ffmpeg ( path , verbose = False ): \"\"\" ## validate_ffmpeg Validate FFmeg Binaries. returns `True` if tests are passed. Parameters: path (string): absolute path of FFmpeg binaries verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" try : # get the FFmpeg version version = check_sp_output ([ path , \"-version\" ]) firstline = version . split ( b \" \\n \" )[ 0 ] version = firstline . split ( b \" \" )[ 2 ] . strip () if verbose : # log if test are passed logger . debug ( \"FFmpeg validity Test Passed!\" ) logger . debug ( \"Found valid FFmpeg Version: ` {} ` installed on this system\" . format ( version ) ) except Exception as e : # log if test are failed if verbose : logger . exception ( str ( e )) logger . warning ( \"FFmpeg validity Test Failed!\" ) return False return True get_supported_pixfmts \u00b6 Find and returns FFmpeg's supported pixel formats Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported pixel formats as (PIXEL FORMAT, NB_COMPONENTS, BITS_PER_PIXEL). Source code in deffcode/ffhelper.py def get_supported_pixfmts ( path ): \"\"\" ## get_supported_pixfmts Find and returns FFmpeg's supported pixel formats Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported pixel formats as (PIXEL FORMAT, NB_COMPONENTS, BITS_PER_PIXEL). \"\"\" pxfmts = check_sp_output ([ path , \"-hide_banner\" , \"-pix_fmts\" ]) splitted = pxfmts . split ( b \" \\n \" ) srtindex = [ i for i , s in enumerate ( splitted ) if b \"-----\" in s ] # extract video encoders supported_pxfmts = [ x . decode ( \"utf-8\" ) . strip () for x in splitted [ srtindex [ 0 ] + 1 :] if x . decode ( \"utf-8\" ) . strip () ] # compile regex finder = re . compile ( r \"([A-Z]*[\\.]+[A-Z]*\\s[a-z0-9_-]*)(\\s+[0-4])(\\s+[0-9]+)\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_pxfmts )) # return output findings return [ ([ s for s in o [ 0 ] . split ( \" \" )][ - 1 ], o [ 1 ] . strip (), o [ 2 ] . strip ()) for o in outputs if len ( o ) == 3 ] get_supported_vdecoders \u00b6 Find and returns FFmpeg's supported video decoders Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported decoders. Source code in deffcode/ffhelper.py def get_supported_vdecoders ( path ): \"\"\" ## get_supported_vdecoders Find and returns FFmpeg's supported video decoders Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported decoders. \"\"\" decoders = check_sp_output ([ path , \"-hide_banner\" , \"-decoders\" ]) splitted = decoders . split ( b \" \\n \" ) # extract video encoders supported_vdecoders = [ x . decode ( \"utf-8\" ) . strip () for x in splitted [ 2 : len ( splitted ) - 1 ] if x . decode ( \"utf-8\" ) . strip () . startswith ( \"V\" ) ] # compile regex finder = re . compile ( r \"[A-Z]*[\\.]+[A-Z]*\\s[a-z0-9_-]*\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_vdecoders )) # return output findings return [[ s for s in o . split ( \" \" )][ - 1 ] for o in outputs ] get_supported_demuxers \u00b6 Find and returns FFmpeg's supported demuxers Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported demuxers. Source code in deffcode/ffhelper.py def get_supported_demuxers ( path ): \"\"\" ## get_supported_demuxers Find and returns FFmpeg's supported demuxers Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported demuxers. \"\"\" demuxers = check_sp_output ([ path , \"-hide_banner\" , \"-demuxers\" ]) splitted = [ x . decode ( \"utf-8\" ) . strip () for x in demuxers . split ( b \" \\n \" )] supported_demuxers = splitted [ splitted . index ( \"--\" ) + 1 : len ( splitted ) - 1 ] # compile regex finder = re . compile ( r \"\\s\\s[a-z0-9_,-]+\\s+\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_demuxers )) # return output findings return [ o . strip () for o in outputs ] validate_imgseqdir \u00b6 Validates Image Sequence by counting number of Image files. Parameters: Name Type Description Default source string video source to be validated required extension string extension of image sequence. 'jpg' Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def validate_imgseqdir ( source , extension = \"jpg\" , verbose = False ): \"\"\" ## validate_imgseqdir Validates Image Sequence by counting number of Image files. Parameters: source (string): video source to be validated extension (string): extension of image sequence. **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" # check if path exists dirpath = Path ( source ) . parent try : if not ( dirpath . exists () and dirpath . is_dir ()): verbose and logger . warning ( \"Specified path ` {} ` doesn't exists or valid.\" . format ( dirpath ) ) return False else : return ( True if len ( list ( dirpath . glob ( \"*. {} \" . format ( extension )))) > 2 else False ) except : return False is_valid_image_seq \u00b6 Checks Image sequence validity by testing its extension against FFmpeg's supported pipe formats and number of Image files. Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required source string video source to be validated None verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def is_valid_image_seq ( path , source = None , verbose = False ): \"\"\" ## is_valid_image_seq Checks Image sequence validity by testing its extension against FFmpeg's supported pipe formats and number of Image files. Parameters: path (string): absolute path of FFmpeg binaries source (string): video source to be validated verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" if source is None or not ( source ): logger . error ( \"Source is empty!\" ) return False # extract all FFmpeg supported protocols formats = check_sp_output ([ path , \"-hide_banner\" , \"-formats\" ]) extract_formats = re . findall ( r \"\\w+_pipe\" , formats . decode ( \"utf-8\" ) . strip ()) supported_image_formats = [ x . split ( \"_\" )[ 0 ] for x in extract_formats if x . endswith ( \"_pipe\" ) ] filename , extension = os . path . splitext ( source ) # Test and return result whether scheme is supported if extension and source . endswith ( tuple ( supported_image_formats )): if validate_imgseqdir ( source , extension = extension [ 1 :], verbose = verbose ): verbose and logger . debug ( \"A valid Image Sequence source of format ` {} ` found.\" . format ( extension ) ) return True else : ValueError ( \"Given Image Sequence source of format ` {} ` contains insignificant(invalid) sample size, Check the `source` parameter value again!\" . format ( source . split ( \".\" )[ 1 ] ) ) else : verbose and logger . warning ( \"Source isn't a valid Image Sequence\" ) return False is_valid_url \u00b6 Checks URL validity by testing its scheme against FFmpeg's supported protocols Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required url string URL to be validated None verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def is_valid_url ( path , url = None , verbose = False ): \"\"\" ## is_valid_url Checks URL validity by testing its scheme against FFmpeg's supported protocols Parameters: path (string): absolute path of FFmpeg binaries url (string): URL to be validated verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" if url is None or not ( url ): logger . warning ( \"URL is empty!\" ) return False # extract URL scheme extracted_scheme_url = url . split ( \"://\" , 1 )[ 0 ] # extract all FFmpeg supported protocols protocols = check_sp_output ([ path , \"-hide_banner\" , \"-protocols\" ]) splitted = [ x . decode ( \"utf-8\" ) . strip () for x in protocols . split ( b \" \\n \" )] supported_protocols = splitted [ splitted . index ( \"Output:\" ) + 1 : len ( splitted ) - 1 ] # rtsp is a demuxer somehow supported_protocols += [ \"rtsp\" ] if \"rtsp\" in get_supported_demuxers ( path ) else [] # Test and return result whether scheme is supported if extracted_scheme_url and extracted_scheme_url in supported_protocols : verbose and logger . debug ( \"URL scheme ` {} ` is supported by FFmpeg.\" . format ( extracted_scheme_url ) ) return True else : verbose and logger . warning ( \"URL scheme ` {} ` isn't supported by FFmpeg!\" . format ( extracted_scheme_url ) ) return False check_sp_output \u00b6 Returns FFmpeg stdout output from subprocess module Parameters: Name Type Description Default args based on input Non Keyword Arguments () kwargs based on input Keyword Arguments {} Returns: A string value. Source code in deffcode/ffhelper.py def check_sp_output ( * args , ** kwargs ): \"\"\" ## check_sp_output Returns FFmpeg `stdout` output from subprocess module Parameters: args (based on input): Non Keyword Arguments kwargs (based on input): Keyword Arguments **Returns:** A string value. \"\"\" # workaround for python bug: https://bugs.python.org/issue37380 if platform . system () == \"Windows\" : # see comment https://bugs.python.org/msg370334 sp . _cleanup = lambda : None # handle additional params retrieve_stderr = kwargs . pop ( \"force_retrieve_stderr\" , False ) # execute command in subprocess process = sp . Popen ( stdout = sp . PIPE , stderr = sp . DEVNULL if not ( retrieve_stderr ) else sp . PIPE , * args , ** kwargs , ) output , stderr = process . communicate () retcode = process . poll () # handle return code if retcode and not ( retrieve_stderr ): cmd = kwargs . get ( \"args\" ) if cmd is None : cmd = args [ 0 ] error = sp . CalledProcessError ( retcode , cmd ) error . output = output raise error return output if not ( retrieve_stderr ) else stderr","title":"deffcode.ffhelper"},{"location":"reference/ffhelper/#deffcode.ffhelper.get_valid_ffmpeg_path--get_valid_ffmpeg_path","text":"Validate the given FFmpeg path/binaries, and returns a valid FFmpeg executable path. Parameters: Name Type Description Default custom_ffmpeg string path to custom FFmpeg executables '' is_windows boolean is running on Windows OS? False ffmpeg_download_path string FFmpeg static binaries download location (Windows only) '' verbose bool enables verbose for its operations False Returns: A valid FFmpeg executable path string. Source code in deffcode/ffhelper.py def get_valid_ffmpeg_path ( custom_ffmpeg = \"\" , is_windows = False , ffmpeg_download_path = \"\" , verbose = False ): \"\"\" ## get_valid_ffmpeg_path Validate the given FFmpeg path/binaries, and returns a valid FFmpeg executable path. Parameters: custom_ffmpeg (string): path to custom FFmpeg executables is_windows (boolean): is running on Windows OS? ffmpeg_download_path (string): FFmpeg static binaries download location _(Windows only)_ verbose (bool): enables verbose for its operations **Returns:** A valid FFmpeg executable path string. \"\"\" final_path = \"\" if is_windows : # checks if current os is windows if custom_ffmpeg : # if custom FFmpeg path is given assign to local variable final_path += custom_ffmpeg else : # otherwise auto-download them try : if not ( ffmpeg_download_path ): # otherwise save to Temp Directory import tempfile ffmpeg_download_path = tempfile . gettempdir () verbose and logger . debug ( \"FFmpeg Windows Download Path: {} \" . format ( ffmpeg_download_path ) ) # download Binaries os_bit = ( ( \"win64\" if platform . machine () . endswith ( \"64\" ) else \"win32\" ) if is_windows else \"\" ) _path = download_ffmpeg_binaries ( path = ffmpeg_download_path , os_windows = is_windows , os_bit = os_bit ) # assign to local variable final_path += _path except Exception as e : # log if any error occurred logger . exception ( str ( e )) logger . error ( \"Error in downloading FFmpeg binaries, Check your network and Try again!\" ) return False if os . path . isfile ( final_path ): # check if valid FFmpeg file exist pass elif os . path . isfile ( os . path . join ( final_path , \"ffmpeg.exe\" )): # check if FFmpeg directory exists, if does, then check for valid file final_path = os . path . join ( final_path , \"ffmpeg.exe\" ) else : # else return False verbose and logger . debug ( \"No valid FFmpeg executables found at Custom FFmpeg path!\" ) return False else : # otherwise perform test for Unix if custom_ffmpeg : # if custom FFmpeg path is given assign to local variable if os . path . isfile ( custom_ffmpeg ): # check if valid FFmpeg file exist final_path += custom_ffmpeg elif os . path . isfile ( os . path . join ( custom_ffmpeg , \"ffmpeg\" )): # check if FFmpeg directory exists, if does, then check for valid file final_path = os . path . join ( custom_ffmpeg , \"ffmpeg\" ) else : # else return False verbose and logger . debug ( \"No valid FFmpeg executables found at Custom FFmpeg path!\" ) return False else : # otherwise assign ffmpeg binaries from system final_path += \"ffmpeg\" verbose and logger . debug ( \"Final FFmpeg Path: {} \" . format ( final_path )) # Final Auto-Validation for FFmeg Binaries. returns final path if test is passed return final_path if validate_ffmpeg ( final_path , verbose = verbose ) else False","title":"get_valid_ffmpeg_path"},{"location":"reference/ffhelper/#deffcode.ffhelper.download_ffmpeg_binaries--download_ffmpeg_binaries","text":"Generates FFmpeg Static Binaries for windows(if not available) Parameters: Name Type Description Default path string path for downloading custom FFmpeg executables required os_windows boolean is running on Windows OS? False os_bit string 32-bit or 64-bit OS? '' Returns: A valid FFmpeg executable path string. Source code in deffcode/ffhelper.py def download_ffmpeg_binaries ( path , os_windows = False , os_bit = \"\" ): \"\"\" ## download_ffmpeg_binaries Generates FFmpeg Static Binaries for windows(if not available) Parameters: path (string): path for downloading custom FFmpeg executables os_windows (boolean): is running on Windows OS? os_bit (string): 32-bit or 64-bit OS? **Returns:** A valid FFmpeg executable path string. \"\"\" final_path = \"\" if os_windows and os_bit : # initialize with available FFmpeg Static Binaries GitHub Server file_url = \"https://github.com/abhiTronix/FFmpeg-Builds/releases/latest/download/ffmpeg-static- {} -gpl.zip\" . format ( os_bit ) file_name = os . path . join ( os . path . abspath ( path ), \"ffmpeg-static- {} -gpl.zip\" . format ( os_bit ) ) file_path = os . path . join ( os . path . abspath ( path ), \"ffmpeg-static- {} -gpl/bin/ffmpeg.exe\" . format ( os_bit ), ) base_path , _ = os . path . split ( file_name ) # extract file base path # check if file already exists if os . path . isfile ( file_path ): final_path += file_path # skip download if does else : # import libs import zipfile # check if given path has write access assert os . access ( path , os . W_OK ), ( \"[Helper:ERROR] :: Permission Denied, Cannot write binaries to directory = \" + path ) # remove leftovers if exists os . path . isfile ( file_name ) and delete_file_safe ( file_name ) # download and write file to the given path with open ( file_name , \"wb\" ) as f : logger . debug ( \"No Custom FFmpeg path provided. Auto-Installing FFmpeg static binaries from GitHub Mirror now. Please wait...\" ) # create session with requests . Session () as http : # setup retry strategy retries = Retry ( total = 3 , backoff_factor = 1 , status_forcelist = [ 429 , 500 , 502 , 503 , 504 ], ) # Mount it for https usage adapter = TimeoutHTTPAdapter ( timeout = 2.0 , max_retries = retries ) http . mount ( \"https://\" , adapter ) response = http . get ( file_url , stream = True ) response . raise_for_status () total_length = response . headers . get ( \"content-length\" ) assert not ( total_length is None ), \"[Helper:ERROR] :: Failed to retrieve files, check your Internet connectivity!\" bar = tqdm ( total = int ( total_length ), unit = \"B\" , unit_scale = True ) for data in response . iter_content ( chunk_size = 4096 ): f . write ( data ) len ( data ) > 0 and bar . update ( len ( data )) bar . close () logger . debug ( \"Extracting executables.\" ) with zipfile . ZipFile ( file_name , \"r\" ) as zip_ref : zip_fname , _ = os . path . split ( zip_ref . infolist ()[ 0 ] . filename ) zip_ref . extractall ( base_path ) # perform cleaning delete_file_safe ( file_name ) logger . debug ( \"FFmpeg binaries for Windows configured successfully!\" ) final_path += file_path # return final path return final_path","title":"download_ffmpeg_binaries"},{"location":"reference/ffhelper/#deffcode.ffhelper.validate_ffmpeg--validate_ffmpeg","text":"Validate FFmeg Binaries. returns True if tests are passed. Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def validate_ffmpeg ( path , verbose = False ): \"\"\" ## validate_ffmpeg Validate FFmeg Binaries. returns `True` if tests are passed. Parameters: path (string): absolute path of FFmpeg binaries verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" try : # get the FFmpeg version version = check_sp_output ([ path , \"-version\" ]) firstline = version . split ( b \" \\n \" )[ 0 ] version = firstline . split ( b \" \" )[ 2 ] . strip () if verbose : # log if test are passed logger . debug ( \"FFmpeg validity Test Passed!\" ) logger . debug ( \"Found valid FFmpeg Version: ` {} ` installed on this system\" . format ( version ) ) except Exception as e : # log if test are failed if verbose : logger . exception ( str ( e )) logger . warning ( \"FFmpeg validity Test Failed!\" ) return False return True","title":"validate_ffmpeg"},{"location":"reference/ffhelper/#deffcode.ffhelper.get_supported_pixfmts--get_supported_pixfmts","text":"Find and returns FFmpeg's supported pixel formats Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported pixel formats as (PIXEL FORMAT, NB_COMPONENTS, BITS_PER_PIXEL). Source code in deffcode/ffhelper.py def get_supported_pixfmts ( path ): \"\"\" ## get_supported_pixfmts Find and returns FFmpeg's supported pixel formats Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported pixel formats as (PIXEL FORMAT, NB_COMPONENTS, BITS_PER_PIXEL). \"\"\" pxfmts = check_sp_output ([ path , \"-hide_banner\" , \"-pix_fmts\" ]) splitted = pxfmts . split ( b \" \\n \" ) srtindex = [ i for i , s in enumerate ( splitted ) if b \"-----\" in s ] # extract video encoders supported_pxfmts = [ x . decode ( \"utf-8\" ) . strip () for x in splitted [ srtindex [ 0 ] + 1 :] if x . decode ( \"utf-8\" ) . strip () ] # compile regex finder = re . compile ( r \"([A-Z]*[\\.]+[A-Z]*\\s[a-z0-9_-]*)(\\s+[0-4])(\\s+[0-9]+)\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_pxfmts )) # return output findings return [ ([ s for s in o [ 0 ] . split ( \" \" )][ - 1 ], o [ 1 ] . strip (), o [ 2 ] . strip ()) for o in outputs if len ( o ) == 3 ]","title":"get_supported_pixfmts"},{"location":"reference/ffhelper/#deffcode.ffhelper.get_supported_vdecoders--get_supported_vdecoders","text":"Find and returns FFmpeg's supported video decoders Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported decoders. Source code in deffcode/ffhelper.py def get_supported_vdecoders ( path ): \"\"\" ## get_supported_vdecoders Find and returns FFmpeg's supported video decoders Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported decoders. \"\"\" decoders = check_sp_output ([ path , \"-hide_banner\" , \"-decoders\" ]) splitted = decoders . split ( b \" \\n \" ) # extract video encoders supported_vdecoders = [ x . decode ( \"utf-8\" ) . strip () for x in splitted [ 2 : len ( splitted ) - 1 ] if x . decode ( \"utf-8\" ) . strip () . startswith ( \"V\" ) ] # compile regex finder = re . compile ( r \"[A-Z]*[\\.]+[A-Z]*\\s[a-z0-9_-]*\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_vdecoders )) # return output findings return [[ s for s in o . split ( \" \" )][ - 1 ] for o in outputs ]","title":"get_supported_vdecoders"},{"location":"reference/ffhelper/#deffcode.ffhelper.get_supported_demuxers--get_supported_demuxers","text":"Find and returns FFmpeg's supported demuxers Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required Returns: List of supported demuxers. Source code in deffcode/ffhelper.py def get_supported_demuxers ( path ): \"\"\" ## get_supported_demuxers Find and returns FFmpeg's supported demuxers Parameters: path (string): absolute path of FFmpeg binaries **Returns:** List of supported demuxers. \"\"\" demuxers = check_sp_output ([ path , \"-hide_banner\" , \"-demuxers\" ]) splitted = [ x . decode ( \"utf-8\" ) . strip () for x in demuxers . split ( b \" \\n \" )] supported_demuxers = splitted [ splitted . index ( \"--\" ) + 1 : len ( splitted ) - 1 ] # compile regex finder = re . compile ( r \"\\s\\s[a-z0-9_,-]+\\s+\" ) # find all outputs outputs = finder . findall ( \" \\n \" . join ( supported_demuxers )) # return output findings return [ o . strip () for o in outputs ]","title":"get_supported_demuxers"},{"location":"reference/ffhelper/#deffcode.ffhelper.validate_imgseqdir--validate_imgseqdir","text":"Validates Image Sequence by counting number of Image files. Parameters: Name Type Description Default source string video source to be validated required extension string extension of image sequence. 'jpg' Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def validate_imgseqdir ( source , extension = \"jpg\" , verbose = False ): \"\"\" ## validate_imgseqdir Validates Image Sequence by counting number of Image files. Parameters: source (string): video source to be validated extension (string): extension of image sequence. **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" # check if path exists dirpath = Path ( source ) . parent try : if not ( dirpath . exists () and dirpath . is_dir ()): verbose and logger . warning ( \"Specified path ` {} ` doesn't exists or valid.\" . format ( dirpath ) ) return False else : return ( True if len ( list ( dirpath . glob ( \"*. {} \" . format ( extension )))) > 2 else False ) except : return False","title":"validate_imgseqdir"},{"location":"reference/ffhelper/#deffcode.ffhelper.is_valid_image_seq--is_valid_image_seq","text":"Checks Image sequence validity by testing its extension against FFmpeg's supported pipe formats and number of Image files. Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required source string video source to be validated None verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def is_valid_image_seq ( path , source = None , verbose = False ): \"\"\" ## is_valid_image_seq Checks Image sequence validity by testing its extension against FFmpeg's supported pipe formats and number of Image files. Parameters: path (string): absolute path of FFmpeg binaries source (string): video source to be validated verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" if source is None or not ( source ): logger . error ( \"Source is empty!\" ) return False # extract all FFmpeg supported protocols formats = check_sp_output ([ path , \"-hide_banner\" , \"-formats\" ]) extract_formats = re . findall ( r \"\\w+_pipe\" , formats . decode ( \"utf-8\" ) . strip ()) supported_image_formats = [ x . split ( \"_\" )[ 0 ] for x in extract_formats if x . endswith ( \"_pipe\" ) ] filename , extension = os . path . splitext ( source ) # Test and return result whether scheme is supported if extension and source . endswith ( tuple ( supported_image_formats )): if validate_imgseqdir ( source , extension = extension [ 1 :], verbose = verbose ): verbose and logger . debug ( \"A valid Image Sequence source of format ` {} ` found.\" . format ( extension ) ) return True else : ValueError ( \"Given Image Sequence source of format ` {} ` contains insignificant(invalid) sample size, Check the `source` parameter value again!\" . format ( source . split ( \".\" )[ 1 ] ) ) else : verbose and logger . warning ( \"Source isn't a valid Image Sequence\" ) return False","title":"is_valid_image_seq"},{"location":"reference/ffhelper/#deffcode.ffhelper.is_valid_url--is_valid_url","text":"Checks URL validity by testing its scheme against FFmpeg's supported protocols Parameters: Name Type Description Default path string absolute path of FFmpeg binaries required url string URL to be validated None verbose bool enables verbose for its operations False Returns: A boolean value, confirming whether tests passed, or not?. Source code in deffcode/ffhelper.py def is_valid_url ( path , url = None , verbose = False ): \"\"\" ## is_valid_url Checks URL validity by testing its scheme against FFmpeg's supported protocols Parameters: path (string): absolute path of FFmpeg binaries url (string): URL to be validated verbose (bool): enables verbose for its operations **Returns:** A boolean value, confirming whether tests passed, or not?. \"\"\" if url is None or not ( url ): logger . warning ( \"URL is empty!\" ) return False # extract URL scheme extracted_scheme_url = url . split ( \"://\" , 1 )[ 0 ] # extract all FFmpeg supported protocols protocols = check_sp_output ([ path , \"-hide_banner\" , \"-protocols\" ]) splitted = [ x . decode ( \"utf-8\" ) . strip () for x in protocols . split ( b \" \\n \" )] supported_protocols = splitted [ splitted . index ( \"Output:\" ) + 1 : len ( splitted ) - 1 ] # rtsp is a demuxer somehow supported_protocols += [ \"rtsp\" ] if \"rtsp\" in get_supported_demuxers ( path ) else [] # Test and return result whether scheme is supported if extracted_scheme_url and extracted_scheme_url in supported_protocols : verbose and logger . debug ( \"URL scheme ` {} ` is supported by FFmpeg.\" . format ( extracted_scheme_url ) ) return True else : verbose and logger . warning ( \"URL scheme ` {} ` isn't supported by FFmpeg!\" . format ( extracted_scheme_url ) ) return False","title":"is_valid_url"},{"location":"reference/ffhelper/#deffcode.ffhelper.check_sp_output--check_sp_output","text":"Returns FFmpeg stdout output from subprocess module Parameters: Name Type Description Default args based on input Non Keyword Arguments () kwargs based on input Keyword Arguments {} Returns: A string value. Source code in deffcode/ffhelper.py def check_sp_output ( * args , ** kwargs ): \"\"\" ## check_sp_output Returns FFmpeg `stdout` output from subprocess module Parameters: args (based on input): Non Keyword Arguments kwargs (based on input): Keyword Arguments **Returns:** A string value. \"\"\" # workaround for python bug: https://bugs.python.org/issue37380 if platform . system () == \"Windows\" : # see comment https://bugs.python.org/msg370334 sp . _cleanup = lambda : None # handle additional params retrieve_stderr = kwargs . pop ( \"force_retrieve_stderr\" , False ) # execute command in subprocess process = sp . Popen ( stdout = sp . PIPE , stderr = sp . DEVNULL if not ( retrieve_stderr ) else sp . PIPE , * args , ** kwargs , ) output , stderr = process . communicate () retcode = process . poll () # handle return code if retcode and not ( retrieve_stderr ): cmd = kwargs . get ( \"args\" ) if cmd is None : cmd = args [ 0 ] error = sp . CalledProcessError ( retcode , cmd ) error . output = output raise error return output if not ( retrieve_stderr ) else stderr","title":"check_sp_output"},{"location":"reference/utils/","text":"logger_handler \u00b6 Returns the logger handler Returns: A logger handler Source code in deffcode/utils.py def logger_handler (): \"\"\" ## logger_handler Returns the logger handler **Returns:** A logger handler \"\"\" # logging formatter formatter = ColoredFormatter ( \" {green}{asctime}{reset} :: {bold_purple}{name:^13}{reset} :: {log_color}{levelname:^8}{reset} :: {bold_white}{message} \" , datefmt = \"%H:%M:%S\" , reset = True , log_colors = { \"INFO\" : \"bold_cyan\" , \"DEBUG\" : \"bold_yellow\" , \"WARNING\" : \"bold_red,fg_thin_yellow\" , \"ERROR\" : \"bold_red\" , \"CRITICAL\" : \"bold_red,bg_white\" , }, style = \"{\" , ) # check if FFdecoder_LOGFILE defined file_mode = os . environ . get ( \"DEFFCODE_LOGFILE\" , False ) # define handler handler = logging . StreamHandler () if file_mode and isinstance ( file_mode , str ): file_path = os . path . abspath ( file_mode ) if ( os . name == \"nt\" or os . access in os . supports_effective_ids ) and os . access ( os . path . dirname ( file_path ), os . W_OK ): file_path = ( os . path . join ( file_path , \"deffcode.log\" ) if os . path . isdir ( file_path ) else file_path ) handler = logging . FileHandler ( file_path , mode = \"a\" ) formatter = logging . Formatter ( \" {asctime} :: {name} :: {levelname} :: {message} \" , datefmt = \"%H:%M:%S\" , style = \"{\" , ) handler . setFormatter ( formatter ) return handler dict2Args \u00b6 Converts dictionary attributes to list(args) Parameters: Name Type Description Default param_dict dict Parameters dictionary required Returns: Arguments list Source code in deffcode/utils.py def dict2Args ( param_dict ): \"\"\" ## dict2Args Converts dictionary attributes to list(args) Parameters: param_dict (dict): Parameters dictionary **Returns:** Arguments list \"\"\" args = [] for key in param_dict . keys (): if key in [ \"-clones\" ] or key . startswith ( \"-core\" ): if isinstance ( param_dict [ key ], list ): args . extend ( param_dict [ key ]) else : logger . warning ( \" {} with invalid datatype:` {} `, Skipped!\" . format ( \"Core parameter\" if key . startswith ( \"-core\" ) else \"Clone\" , param_dict [ key ], ) ) else : args . append ( key ) args . append ( str ( param_dict [ key ])) return args delete_ext_safe \u00b6 Safely deletes files at given path. Parameters: Name Type Description Default file_path string path to the file required Source code in deffcode/utils.py def delete_file_safe ( file_path ): \"\"\" ## delete_ext_safe Safely deletes files at given path. Parameters: file_path (string): path to the file \"\"\" try : dfile = Path ( file_path ) if sys . version_info >= ( 3 , 8 , 0 ): dfile . unlink ( missing_ok = True ) else : dfile . exists () and dfile . unlink () except Exception as e : logger . exception ( str ( e ))","title":"deffcode.utils"},{"location":"reference/utils/#deffcode.utils.logger_handler--logger_handler","text":"Returns the logger handler Returns: A logger handler Source code in deffcode/utils.py def logger_handler (): \"\"\" ## logger_handler Returns the logger handler **Returns:** A logger handler \"\"\" # logging formatter formatter = ColoredFormatter ( \" {green}{asctime}{reset} :: {bold_purple}{name:^13}{reset} :: {log_color}{levelname:^8}{reset} :: {bold_white}{message} \" , datefmt = \"%H:%M:%S\" , reset = True , log_colors = { \"INFO\" : \"bold_cyan\" , \"DEBUG\" : \"bold_yellow\" , \"WARNING\" : \"bold_red,fg_thin_yellow\" , \"ERROR\" : \"bold_red\" , \"CRITICAL\" : \"bold_red,bg_white\" , }, style = \"{\" , ) # check if FFdecoder_LOGFILE defined file_mode = os . environ . get ( \"DEFFCODE_LOGFILE\" , False ) # define handler handler = logging . StreamHandler () if file_mode and isinstance ( file_mode , str ): file_path = os . path . abspath ( file_mode ) if ( os . name == \"nt\" or os . access in os . supports_effective_ids ) and os . access ( os . path . dirname ( file_path ), os . W_OK ): file_path = ( os . path . join ( file_path , \"deffcode.log\" ) if os . path . isdir ( file_path ) else file_path ) handler = logging . FileHandler ( file_path , mode = \"a\" ) formatter = logging . Formatter ( \" {asctime} :: {name} :: {levelname} :: {message} \" , datefmt = \"%H:%M:%S\" , style = \"{\" , ) handler . setFormatter ( formatter ) return handler","title":"logger_handler"},{"location":"reference/utils/#deffcode.utils.dict2Args--dict2args","text":"Converts dictionary attributes to list(args) Parameters: Name Type Description Default param_dict dict Parameters dictionary required Returns: Arguments list Source code in deffcode/utils.py def dict2Args ( param_dict ): \"\"\" ## dict2Args Converts dictionary attributes to list(args) Parameters: param_dict (dict): Parameters dictionary **Returns:** Arguments list \"\"\" args = [] for key in param_dict . keys (): if key in [ \"-clones\" ] or key . startswith ( \"-core\" ): if isinstance ( param_dict [ key ], list ): args . extend ( param_dict [ key ]) else : logger . warning ( \" {} with invalid datatype:` {} `, Skipped!\" . format ( \"Core parameter\" if key . startswith ( \"-core\" ) else \"Clone\" , param_dict [ key ], ) ) else : args . append ( key ) args . append ( str ( param_dict [ key ])) return args","title":"dict2Args"},{"location":"reference/utils/#deffcode.utils.delete_file_safe--delete_ext_safe","text":"Safely deletes files at given path. Parameters: Name Type Description Default file_path string path to the file required Source code in deffcode/utils.py def delete_file_safe ( file_path ): \"\"\" ## delete_ext_safe Safely deletes files at given path. Parameters: file_path (string): path to the file \"\"\" try : dfile = Path ( file_path ) if sys . version_info >= ( 3 , 8 , 0 ): dfile . unlink ( missing_ok = True ) else : dfile . exists () and dfile . unlink () except Exception as e : logger . exception ( str ( e ))","title":"delete_ext_safe"},{"location":"reference/ffdecoder/","text":"FFdecoder API \u00b6 DeFFcode's FFdecoder API is a powerful real-time Video-frames Generator build on FFmpeg , that keeps on generating 3D 24-bit RGB (default) NumPy's ndarray frames from its pipeline with low-memory overhead continuously. FFdecoder supports a wide range of media stream such as any Video Input devices like USB Cameras, Multimedia video file format, Screen Captures, Image Sequences, plus any network stream URL (such as http(s), rtp, rstp, rtmp, mms, etc.) . FFdecoder API wraps FFmpeg pipeline inside a subprocess that run as completely independent entities and executes the pipeline concurrently with original process, extracting dataframes(in bytes) into NumPy's buffer(as a 1D array) from its stdout output. These dataframes are then converted into 3D NumPy's ndarray frames that are supported by almost all prominent Computer Vision libraries like OpenCV, Pytorch, dlib ,etc. and can be easily employed to perform various digital processing functions (like translation, rotation, resizing, cropping, fading, scaling) on-the-go. FFdecoder API can extract frames in real-time with any custom specification imaginable such as Framerate, Resolution, Hardware decoding, Complex Filters into any pixel format that FFmpeg supports along with desired parameters. Furthermore, This API also supports extraction of Source Metadata of all specified valid streams as Pretty JSON as well as its updation with user-defined dictionary. \u2009 For usage, kindly refer our Basic Recipes and Advanced Recipes FFdecoder API parameters are explained here \u27b6 Source code in deffcode/ffdecoder.py class FFdecoder : \"\"\" \"\"\" def __init__ ( self , source , frame_format = None , custom_ffmpeg = \"\" , verbose = False , ** extraparams ): \"\"\" This constructor method initializes the object state and attributes of the FFdecoder. Parameters: source (str): defines the default input source. frame_format (str): sets pixel format(-pix_fmt) of the decoded frames. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. verbose (bool): enables/disables verbose. extraparams (dict): provides the flexibility to control supported internal parameters and FFmpeg properties. \"\"\" # enable verbose if specified self . __verbose_logs = ( verbose if ( verbose and isinstance ( verbose , bool )) else False ) # define whether initializing self . __initializing = True # define frame pixel-format for decoded frames self . __frame_format = frame_format # handles user-defined parameters self . __extra_params = {} # handle process to be frames written self . __process = None # handle valid FFmpeg assets location self . __ffmpeg = \"\" # handle exclusive metadata self . __ff_pixfmt_metadata = None # metadata self . __raw_frame_num = None # raw-frame number self . __raw_frame_pixfmt = None # raw-frame pixformat self . __raw_frame_dtype = None # raw-frame dtype self . __raw_frame_depth = None # raw-frame depth self . __raw_frame_resolution = None # raw-frame resolution/dimension # define supported mode of operation self . __supported_opmodes = { \"av\" : \"Audio-Video\" , # audio is only for pass-through, not really for audio decoding yet. \"vo\" : \"Video-Only\" , \"imgseq\" : \"Image-Sequence\" , # \"ao\":\"Audio-Only\", # reserved for future } # operation mode variable self . __opmode = None # handle termination self . __terminate_stream = False # cleans and reformat user-defined parameters self . __extra_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in extraparams . items () } # handle custom Sourcer API params sourcer_params = self . __extra_params . pop ( \"-custom_sourcer_params\" , {}) # reset improper values sourcer_params = {} if not isinstance ( sourcer_params , dict ) else sourcer_params # pass parameter(if specified) to Sourcer API, specifying where to save the downloaded FFmpeg Static # assets on Windows(if specified) sourcer_params [ \"-ffmpeg_download_path\" ] = self . __extra_params . pop ( \"-ffmpeg_download_path\" , \"\" ) # handle video and audio stream indexes in case of multiple ones. default_stream_indexes = self . __extra_params . pop ( \"-default_stream_indexes\" , ( 0 , 0 ) ) # reset improper values default_stream_indexes = ( ( 0 , 0 ) if not isinstance ( default_stream_indexes , ( list , tuple )) else default_stream_indexes ) # extract and assign source metadata as dict self . __source_metadata = ( Sourcer ( source = source , verbose = verbose , ffmpeg_path = self . __ffmpeg , ** sourcer_params ) . probe_stream ( default_stream_indexes = default_stream_indexes ) . retrieve_metadata () ) # get valid ffmpeg path self . __ffmpeg = self . __source_metadata [ \"ffmpeg_binary_path\" ] # handle pass-through audio mode works in conjunction with WriteGear [WIP] self . __passthrough_mode = self . __extra_params . pop ( \"-passthrough_audio\" , False ) if not ( isinstance ( self . __passthrough_mode , bool )): self . __passthrough_mode = False # handle mode of operation if self . __source_metadata [ \"source_has_image_sequence\" ]: # image-sequence mode self . __opmode = \"imgseq\" elif ( self . __source_metadata [ \"source_has_video\" ] # audio is only for pass-through, not really for audio decoding yet. and self . __source_metadata [ \"source_has_audio\" ] and self . __passthrough_mode # [WIP] ): self . __opmode = \"av\" # elif __defop_mode == \"ao\" and self.__source_metadata.contains_audio: # [TODO] # self.__opmode = \"ao\" elif self . __source_metadata [ \"source_has_video\" ]: # video-only mode self . __opmode = \"vo\" else : # raise if unknown mode raise ValueError ( \"Unable to find suitable/usable video stream in the given source!\" ) # store as metadata self . __source_metadata [ \"ffdecoder_operational_mode\" ] = self . __supported_opmodes [ self . __opmode ] # and log it self . __verbose_logs and logger . critical ( \"Activating {} Mode of Operation.\" . format ( self . __supported_opmodes [ self . __opmode ] ) ) # handle user-defined framerate self . __inputframerate = self . __extra_params . pop ( \"-framerate\" , 0.0 ) if ( isinstance ( self . __inputframerate , ( float , int )) and self . __inputframerate > 0.0 ): # must be float self . __inputframerate = float ( self . __inputframerate ) else : # reset improper values self . __inputframerate = 0.0 # FFmpeg parameter `-s` is unsupported if not ( self . __extra_params . pop ( \"-s\" , None ) is None ): logger . warning ( \"Discarding user-defined `-s` FFmpeg parameter as it can only be assigned with `-custom_resolution`!\" ) # handle user defined decoded frame resolution(must be a tuple or list) self . __custom_resolution = self . __extra_params . pop ( \"-custom_resolution\" , None ) if self . __custom_resolution is None or not ( isinstance ( self . __custom_resolution , ( list , tuple )) and len ( self . __custom_resolution ) == 2 ): # reset improper values self . __custom_resolution = None # handle user defined ffmpeg pre-headers(parameters such as `-re`) parameters (must be a list) self . __ffmpeg_prefixes = self . __extra_params . pop ( \"-ffprefixes\" , []) if not isinstance ( self . __ffmpeg_prefixes , list ): # reset improper values self . __ffmpeg_prefixes = [] # handle user defined ffmpeg post-headers(parameters before `-i`) parameters (must be a list) self . __ffmpeg_postfixes = self . __extra_params . pop ( \"-ffpostfixes\" , []) if not isinstance ( self . __ffmpeg_postfixes , list ): # reset improper values self . __ffmpeg_postfixes = [] def formulate ( self ): \"\"\" Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. \"\"\" # assign values to class variables on first run if self . __initializing : # prepare parameter dict input_params = OrderedDict () output_params = OrderedDict () # dynamically pre-assign a default video-decoder (if not assigned by user). supported_vdecodecs = get_supported_vdecoders ( self . __ffmpeg ) default_vdecodec = ( self . __source_metadata [ \"source_video_decoder\" ] if self . __source_metadata [ \"source_video_decoder\" ] in supported_vdecodecs else \"unknown\" ) if \"-c:v\" in self . __extra_params : self . __extra_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-c:v\" , default_vdecodec ) # handle image sequence separately if self . __opmode == \"imgseq\" : # -vcodec is discarded by default # (This is correct or maybe -vcodec required in some unknown case) [TODO] self . __extra_params . pop ( \"-vcodec\" , None ) elif ( \"-vcodec\" in self . __extra_params and self . __extra_params [ \"-vcodec\" ] is None ): # special case when -vcodec is not needed intentionally self . __extra_params . pop ( \"-vcodec\" , None ) else : # assign video decoder selected here. if not \"-vcodec\" in self . __extra_params : input_params [ \"-vcodec\" ] = default_vdecodec else : input_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-vcodec\" , default_vdecodec ) if ( default_vdecodec != \"unknown\" and not input_params [ \"-vcodec\" ] in supported_vdecodecs ): # reset to default if not supported logger . warning ( \"Provided FFmpeg does not support ` {} ` video decoder. Switching to default supported ` {} ` decoder!\" . format ( input_params [ \"-vcodec\" ], default_vdecodec ) ) input_params [ \"-vcodec\" ] = default_vdecodec # raise error if not valid decoder found if not input_params [ \"-vcodec\" ] in supported_vdecodecs : raise RuntimeError ( \"Provided FFmpeg does not support any known usable video-decoders.\" \" Either define your own manually or switch to another FFmpeg binaries(if available).\" ) # handle user-defined number of frames. if \"-vframes\" in self . __extra_params : self . __extra_params [ \"-frames:v\" ] = self . __extra_params . pop ( \"-vframes\" , None ) if \"-frames:v\" in self . __extra_params : value = self . __extra_params . pop ( \"-frames:v\" , None ) if not ( value is None ) and value > 0 : output_params [ \"-frames:v\" ] = value # dynamically calculate raw-frame pixel format based on source (if not assigned by user). self . __ff_pixfmt_metadata = get_supported_pixfmts ( self . __ffmpeg ) supported_pixfmts = [ fmts [ 0 ] for fmts in self . __ff_pixfmt_metadata ] default_pixfmt = ( \"rgb24\" if \"rgb24\" in supported_pixfmts else self . __source_metadata [ \"source_video_pixfmt\" ] ) if \"-pix_fmt\" in self . __extra_params : logger . warning ( \"Discarding user-defined `-pix_fmt` value as it can only be assigned with `frame_format` parameter!\" ) self . __extra_params . pop ( \"-pix_fmt\" , None ) if ( self . __frame_format is None or not self . __frame_format in supported_pixfmts ): # reset to default if not supported not ( self . __frame_format is None ) and logger . critical ( \"Provided FFmpeg does not support ` {} ` pixel format(pix_fmt). Switching to default ` {} `!\" . format ( self . __frame_format , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt else : output_params [ \"-pix_fmt\" ] = self . __frame_format # dynamically calculate raw-frame dtype based on pix format selected frames_pixfmt = output_params [ \"-pix_fmt\" ] ( self . __raw_frame_depth , rawframesbpp ) = [ ( int ( x [ 1 ]), int ( x [ 2 ])) for x in self . __ff_pixfmt_metadata if x [ 0 ] == frames_pixfmt ][ 0 ] raw_bit_per_component = rawframesbpp // self . __raw_frame_depth if raw_bit_per_component in [ 4 , 8 ]: self . __raw_frame_dtype = np . dtype ( \"u1\" ) elif raw_bit_per_component == 16 : if frames_pixfmt . endswith ( \"le\" ): self . __raw_frame_dtype = np . dtype ( \"<u2\" ) elif frames_pixfmt . endswith ( \"be\" ): self . __raw_frame_dtype = np . dtype ( \">u2\" ) else : pass else : # reset to default if not supported logger . critical ( \"Given `frame_format` value: {} is not supported by FFdecoder. Switching to default ` {} `!\" . format ( frames_pixfmt , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt self . __raw_frame_dtype = np . dtype ( \"u1\" ) self . __raw_frame_pixfmt = output_params [ \"-pix_fmt\" ] # dynamically calculate raw-frame resolution/dimensions based on source (if not assigned by user). self . __raw_frame_resolution = ( self . __custom_resolution if not ( self . __custom_resolution is None ) else self . __source_metadata [ \"source_video_resolution\" ] ) dimensions = \" {} x {} \" . format ( self . __raw_frame_resolution [ 0 ], self . __raw_frame_resolution [ 1 ] ) # apply if defined output_params [ \"-s\" ] = str ( dimensions ) # dynamically calculate raw-frame frame-rate based on source (if not assigned by user). framerate = ( self . __inputframerate if self . __inputframerate > 0.0 else self . __source_metadata [ \"source_video_framerate\" ] ) output_params [ \"-framerate\" ] = str ( framerate ) # add rest to output parameters output_params . update ( self . __extra_params ) # dynamically calculate raw-frame numbers based on source (if not assigned by user). if \"-frames:v\" in input_params : self . __raw_frame_num = input_params [ \"-frames:v\" ] elif self . __source_metadata [ \"approx_video_nframes\" ]: self . __raw_frame_num = self . __source_metadata [ \"approx_video_nframes\" ] else : self . __raw_frame_num = None # log that number of frames are unknown self . __verbose_logs and logger . info ( \"Live/Network Stream detected! Number of frames for given source is unknown.\" ) # compose the Pipeline using formulated FFmpeg parameters self . __launch_FFdecoderline ( input_params , output_params ) # inform the initialization is completed self . __initializing = False else : # warn if pipeline is recreated logger . error ( \"This pipeline is already created and running!\" ) return self def __fetchNextfromPipeline ( self ): \"\"\" Internal method to fetch next dataframe(in bytes) from FFmpeg Pipeline. \"\"\" assert not ( self . __process is None ), \"Pipeline is not running! Check if you called `create()` method.\" # formulated raw frame size raw_frame_size = ( self . __raw_frame_depth * self . __raw_frame_resolution [ 0 ] * self . __raw_frame_resolution [ 1 ] ) # next dataframe as numpy ndarray nparray = None try : # read bytes frames from buffer nparray = np . frombuffer ( self . __process . stdout . read ( raw_frame_size * self . __raw_frame_dtype . itemsize ), dtype = self . __raw_frame_dtype , ) except Exception as e : raise RuntimeError ( \"Frame fetching failed with error: {} \" . format ( str ( e ))) return ( nparray if not ( nparray is None ) and len ( nparray ) == raw_frame_size else None ) def __fetchNextFrame ( self ): \"\"\" Internal method to reconstruct next video-frame(`ndarray`) from fetched dataframe. \"\"\" # Read next and reconstruct as numpy array frame = self . __fetchNextfromPipeline () # check if empty if frame is None : return frame elif self . __raw_frame_pixfmt . startswith ( \"gray\" ): # reconstruct gray frames frame = frame . reshape ( ( self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], self . __raw_frame_depth , ) )[:, :, 0 ] elif self . __raw_frame_pixfmt == \"yuv444p\" : # reconstruct exclusive frames frame = frame . reshape ( ( self . __raw_frame_depth , self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], ) ) . transpose (( 1 , 2 , 0 )) else : # reconstruct default frames frame = frame . reshape ( ( self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], self . __raw_frame_depth , ) ) # return frame return frame def generateFrame ( self ): \"\"\" A python Generator function which can also works as an Iterator(using `next()`) for extracting video-frames(`ndarray`) at rapid pace. \"\"\" if self . __raw_frame_num is None or not self . __raw_frame_num : while not self . __terminate_stream : frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True continue yield frame else : for _ in range ( self . __raw_frame_num ): frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True break yield frame def __enter__ ( self ): \"\"\" Handles entry \"\"\" return self def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" Handles exit \"\"\" self . close () @property def metadata ( self ): \"\"\" A property object that dumps Source metadata dict as JSON for pretty printing. As well as can be used to update source metadata with user-defined dictionary. **Returns:** A [`json.dumps`](https://docs.python.org/3/library/json.html#json.dumps) output. \"\"\" return json . dumps ( self . __source_metadata , indent = 2 ) @metadata . setter def metadata ( self , value ): \"\"\" A property object that updates source metadata with user-defined dictionary. Parameters: value (dict): User-defined dictionary. \"\"\" self . __verbose_logs and logger . info ( \"Updating Metadata...\" ) if value and isinstance ( value , dict ): self . __source_metadata . update ( value ) else : raise ValueError ( \"Invalid value specified.\" ) def __launch_FFdecoderline ( self , input_params , output_params ): \"\"\" An Internal method that launches FFmpeg Pipeline using subprocess module, that pipelines dataframes(in bytes) to `stdout`. Parameters: input_params (dict): Input FFmpeg parameters output_params (dict): Output FFmpeg parameters \"\"\" # convert input parameters to list input_parameters = dict2Args ( input_params ) # convert output parameters to list output_parameters = dict2Args ( output_params ) # format command cmd = ( [ self . __ffmpeg ] + self . __ffmpeg_prefixes + input_parameters + self . __ffmpeg_postfixes + [ \"-i\" ] + [ self . __source_metadata [ \"source\" ]] + output_parameters + [ \"-f\" , \"rawvideo\" , \"-\" ] ) # assign value to class variable _cmd = \" \" . join ( cmd ) # compose the FFmpeg process if self . __verbose_logs : logger . debug ( \"Executing FFmpeg command: ` {} `\" . format ( _cmd )) # In debugging mode self . __process = sp . Popen ( cmd , stdin = sp . PIPE , stdout = sp . PIPE , stderr = None ) else : # In silent mode self . __process = sp . Popen ( cmd , stdin = sp . PIPE , stdout = sp . PIPE , stderr = sp . DEVNULL ) def terminate ( self ): \"\"\" Safely terminate all processes. \"\"\" # signal we are closing self . __verbose_logs and logger . debug ( \"Terminating FFdecoder Pipeline...\" ) self . __terminate_stream = True # Attempt to close pipeline. if self . __process is None or not ( self . __process . poll () is None ): return # no process was initiated at first place # close `stdin` output self . __process . stdin and self . __process . stdin . close () # close `stdout` output self . __process . stdout and self . __process . stdout . close () # wait if still process is still processing some information if self . __process . poll () is None : self . __process . terminate () self . __process . wait () self . __process = None metadata property writable \u00b6 A property object that dumps Source metadata dict as JSON for pretty printing. As well as can be used to update source metadata with user-defined dictionary. Returns: A json.dumps output. __enter__ ( self ) special \u00b6 Handles entry Source code in deffcode/ffdecoder.py def __enter__ ( self ): \"\"\" Handles entry \"\"\" return self __exit__ ( self , exc_type , exc_val , exc_tb ) special \u00b6 Handles exit Source code in deffcode/ffdecoder.py def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" Handles exit \"\"\" self . close () __init__ ( self , source , frame_format = None , custom_ffmpeg = '' , verbose = False , ** extraparams ) special \u00b6 This constructor method initializes the object state and attributes of the FFdecoder. Parameters: Name Type Description Default source str defines the default input source. required frame_format str sets pixel format(-pix_fmt) of the decoded frames. None custom_ffmpeg str assigns the location of custom path/directory for custom FFmpeg executable. '' verbose bool enables/disables verbose. False extraparams dict provides the flexibility to control supported internal parameters and FFmpeg properties. {} Source code in deffcode/ffdecoder.py def __init__ ( self , source , frame_format = None , custom_ffmpeg = \"\" , verbose = False , ** extraparams ): \"\"\" This constructor method initializes the object state and attributes of the FFdecoder. Parameters: source (str): defines the default input source. frame_format (str): sets pixel format(-pix_fmt) of the decoded frames. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. verbose (bool): enables/disables verbose. extraparams (dict): provides the flexibility to control supported internal parameters and FFmpeg properties. \"\"\" # enable verbose if specified self . __verbose_logs = ( verbose if ( verbose and isinstance ( verbose , bool )) else False ) # define whether initializing self . __initializing = True # define frame pixel-format for decoded frames self . __frame_format = frame_format # handles user-defined parameters self . __extra_params = {} # handle process to be frames written self . __process = None # handle valid FFmpeg assets location self . __ffmpeg = \"\" # handle exclusive metadata self . __ff_pixfmt_metadata = None # metadata self . __raw_frame_num = None # raw-frame number self . __raw_frame_pixfmt = None # raw-frame pixformat self . __raw_frame_dtype = None # raw-frame dtype self . __raw_frame_depth = None # raw-frame depth self . __raw_frame_resolution = None # raw-frame resolution/dimension # define supported mode of operation self . __supported_opmodes = { \"av\" : \"Audio-Video\" , # audio is only for pass-through, not really for audio decoding yet. \"vo\" : \"Video-Only\" , \"imgseq\" : \"Image-Sequence\" , # \"ao\":\"Audio-Only\", # reserved for future } # operation mode variable self . __opmode = None # handle termination self . __terminate_stream = False # cleans and reformat user-defined parameters self . __extra_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in extraparams . items () } # handle custom Sourcer API params sourcer_params = self . __extra_params . pop ( \"-custom_sourcer_params\" , {}) # reset improper values sourcer_params = {} if not isinstance ( sourcer_params , dict ) else sourcer_params # pass parameter(if specified) to Sourcer API, specifying where to save the downloaded FFmpeg Static # assets on Windows(if specified) sourcer_params [ \"-ffmpeg_download_path\" ] = self . __extra_params . pop ( \"-ffmpeg_download_path\" , \"\" ) # handle video and audio stream indexes in case of multiple ones. default_stream_indexes = self . __extra_params . pop ( \"-default_stream_indexes\" , ( 0 , 0 ) ) # reset improper values default_stream_indexes = ( ( 0 , 0 ) if not isinstance ( default_stream_indexes , ( list , tuple )) else default_stream_indexes ) # extract and assign source metadata as dict self . __source_metadata = ( Sourcer ( source = source , verbose = verbose , ffmpeg_path = self . __ffmpeg , ** sourcer_params ) . probe_stream ( default_stream_indexes = default_stream_indexes ) . retrieve_metadata () ) # get valid ffmpeg path self . __ffmpeg = self . __source_metadata [ \"ffmpeg_binary_path\" ] # handle pass-through audio mode works in conjunction with WriteGear [WIP] self . __passthrough_mode = self . __extra_params . pop ( \"-passthrough_audio\" , False ) if not ( isinstance ( self . __passthrough_mode , bool )): self . __passthrough_mode = False # handle mode of operation if self . __source_metadata [ \"source_has_image_sequence\" ]: # image-sequence mode self . __opmode = \"imgseq\" elif ( self . __source_metadata [ \"source_has_video\" ] # audio is only for pass-through, not really for audio decoding yet. and self . __source_metadata [ \"source_has_audio\" ] and self . __passthrough_mode # [WIP] ): self . __opmode = \"av\" # elif __defop_mode == \"ao\" and self.__source_metadata.contains_audio: # [TODO] # self.__opmode = \"ao\" elif self . __source_metadata [ \"source_has_video\" ]: # video-only mode self . __opmode = \"vo\" else : # raise if unknown mode raise ValueError ( \"Unable to find suitable/usable video stream in the given source!\" ) # store as metadata self . __source_metadata [ \"ffdecoder_operational_mode\" ] = self . __supported_opmodes [ self . __opmode ] # and log it self . __verbose_logs and logger . critical ( \"Activating {} Mode of Operation.\" . format ( self . __supported_opmodes [ self . __opmode ] ) ) # handle user-defined framerate self . __inputframerate = self . __extra_params . pop ( \"-framerate\" , 0.0 ) if ( isinstance ( self . __inputframerate , ( float , int )) and self . __inputframerate > 0.0 ): # must be float self . __inputframerate = float ( self . __inputframerate ) else : # reset improper values self . __inputframerate = 0.0 # FFmpeg parameter `-s` is unsupported if not ( self . __extra_params . pop ( \"-s\" , None ) is None ): logger . warning ( \"Discarding user-defined `-s` FFmpeg parameter as it can only be assigned with `-custom_resolution`!\" ) # handle user defined decoded frame resolution(must be a tuple or list) self . __custom_resolution = self . __extra_params . pop ( \"-custom_resolution\" , None ) if self . __custom_resolution is None or not ( isinstance ( self . __custom_resolution , ( list , tuple )) and len ( self . __custom_resolution ) == 2 ): # reset improper values self . __custom_resolution = None # handle user defined ffmpeg pre-headers(parameters such as `-re`) parameters (must be a list) self . __ffmpeg_prefixes = self . __extra_params . pop ( \"-ffprefixes\" , []) if not isinstance ( self . __ffmpeg_prefixes , list ): # reset improper values self . __ffmpeg_prefixes = [] # handle user defined ffmpeg post-headers(parameters before `-i`) parameters (must be a list) self . __ffmpeg_postfixes = self . __extra_params . pop ( \"-ffpostfixes\" , []) if not isinstance ( self . __ffmpeg_postfixes , list ): # reset improper values self . __ffmpeg_postfixes = [] formulate ( self ) \u00b6 Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. Source code in deffcode/ffdecoder.py def formulate ( self ): \"\"\" Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. \"\"\" # assign values to class variables on first run if self . __initializing : # prepare parameter dict input_params = OrderedDict () output_params = OrderedDict () # dynamically pre-assign a default video-decoder (if not assigned by user). supported_vdecodecs = get_supported_vdecoders ( self . __ffmpeg ) default_vdecodec = ( self . __source_metadata [ \"source_video_decoder\" ] if self . __source_metadata [ \"source_video_decoder\" ] in supported_vdecodecs else \"unknown\" ) if \"-c:v\" in self . __extra_params : self . __extra_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-c:v\" , default_vdecodec ) # handle image sequence separately if self . __opmode == \"imgseq\" : # -vcodec is discarded by default # (This is correct or maybe -vcodec required in some unknown case) [TODO] self . __extra_params . pop ( \"-vcodec\" , None ) elif ( \"-vcodec\" in self . __extra_params and self . __extra_params [ \"-vcodec\" ] is None ): # special case when -vcodec is not needed intentionally self . __extra_params . pop ( \"-vcodec\" , None ) else : # assign video decoder selected here. if not \"-vcodec\" in self . __extra_params : input_params [ \"-vcodec\" ] = default_vdecodec else : input_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-vcodec\" , default_vdecodec ) if ( default_vdecodec != \"unknown\" and not input_params [ \"-vcodec\" ] in supported_vdecodecs ): # reset to default if not supported logger . warning ( \"Provided FFmpeg does not support ` {} ` video decoder. Switching to default supported ` {} ` decoder!\" . format ( input_params [ \"-vcodec\" ], default_vdecodec ) ) input_params [ \"-vcodec\" ] = default_vdecodec # raise error if not valid decoder found if not input_params [ \"-vcodec\" ] in supported_vdecodecs : raise RuntimeError ( \"Provided FFmpeg does not support any known usable video-decoders.\" \" Either define your own manually or switch to another FFmpeg binaries(if available).\" ) # handle user-defined number of frames. if \"-vframes\" in self . __extra_params : self . __extra_params [ \"-frames:v\" ] = self . __extra_params . pop ( \"-vframes\" , None ) if \"-frames:v\" in self . __extra_params : value = self . __extra_params . pop ( \"-frames:v\" , None ) if not ( value is None ) and value > 0 : output_params [ \"-frames:v\" ] = value # dynamically calculate raw-frame pixel format based on source (if not assigned by user). self . __ff_pixfmt_metadata = get_supported_pixfmts ( self . __ffmpeg ) supported_pixfmts = [ fmts [ 0 ] for fmts in self . __ff_pixfmt_metadata ] default_pixfmt = ( \"rgb24\" if \"rgb24\" in supported_pixfmts else self . __source_metadata [ \"source_video_pixfmt\" ] ) if \"-pix_fmt\" in self . __extra_params : logger . warning ( \"Discarding user-defined `-pix_fmt` value as it can only be assigned with `frame_format` parameter!\" ) self . __extra_params . pop ( \"-pix_fmt\" , None ) if ( self . __frame_format is None or not self . __frame_format in supported_pixfmts ): # reset to default if not supported not ( self . __frame_format is None ) and logger . critical ( \"Provided FFmpeg does not support ` {} ` pixel format(pix_fmt). Switching to default ` {} `!\" . format ( self . __frame_format , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt else : output_params [ \"-pix_fmt\" ] = self . __frame_format # dynamically calculate raw-frame dtype based on pix format selected frames_pixfmt = output_params [ \"-pix_fmt\" ] ( self . __raw_frame_depth , rawframesbpp ) = [ ( int ( x [ 1 ]), int ( x [ 2 ])) for x in self . __ff_pixfmt_metadata if x [ 0 ] == frames_pixfmt ][ 0 ] raw_bit_per_component = rawframesbpp // self . __raw_frame_depth if raw_bit_per_component in [ 4 , 8 ]: self . __raw_frame_dtype = np . dtype ( \"u1\" ) elif raw_bit_per_component == 16 : if frames_pixfmt . endswith ( \"le\" ): self . __raw_frame_dtype = np . dtype ( \"<u2\" ) elif frames_pixfmt . endswith ( \"be\" ): self . __raw_frame_dtype = np . dtype ( \">u2\" ) else : pass else : # reset to default if not supported logger . critical ( \"Given `frame_format` value: {} is not supported by FFdecoder. Switching to default ` {} `!\" . format ( frames_pixfmt , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt self . __raw_frame_dtype = np . dtype ( \"u1\" ) self . __raw_frame_pixfmt = output_params [ \"-pix_fmt\" ] # dynamically calculate raw-frame resolution/dimensions based on source (if not assigned by user). self . __raw_frame_resolution = ( self . __custom_resolution if not ( self . __custom_resolution is None ) else self . __source_metadata [ \"source_video_resolution\" ] ) dimensions = \" {} x {} \" . format ( self . __raw_frame_resolution [ 0 ], self . __raw_frame_resolution [ 1 ] ) # apply if defined output_params [ \"-s\" ] = str ( dimensions ) # dynamically calculate raw-frame frame-rate based on source (if not assigned by user). framerate = ( self . __inputframerate if self . __inputframerate > 0.0 else self . __source_metadata [ \"source_video_framerate\" ] ) output_params [ \"-framerate\" ] = str ( framerate ) # add rest to output parameters output_params . update ( self . __extra_params ) # dynamically calculate raw-frame numbers based on source (if not assigned by user). if \"-frames:v\" in input_params : self . __raw_frame_num = input_params [ \"-frames:v\" ] elif self . __source_metadata [ \"approx_video_nframes\" ]: self . __raw_frame_num = self . __source_metadata [ \"approx_video_nframes\" ] else : self . __raw_frame_num = None # log that number of frames are unknown self . __verbose_logs and logger . info ( \"Live/Network Stream detected! Number of frames for given source is unknown.\" ) # compose the Pipeline using formulated FFmpeg parameters self . __launch_FFdecoderline ( input_params , output_params ) # inform the initialization is completed self . __initializing = False else : # warn if pipeline is recreated logger . error ( \"This pipeline is already created and running!\" ) return self generateFrame ( self ) \u00b6 A python Generator function which can also works as an Iterator(using next() ) for extracting video-frames( ndarray ) at rapid pace. Source code in deffcode/ffdecoder.py def generateFrame ( self ): \"\"\" A python Generator function which can also works as an Iterator(using `next()`) for extracting video-frames(`ndarray`) at rapid pace. \"\"\" if self . __raw_frame_num is None or not self . __raw_frame_num : while not self . __terminate_stream : frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True continue yield frame else : for _ in range ( self . __raw_frame_num ): frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True break yield frame terminate ( self ) \u00b6 Safely terminate all processes. Source code in deffcode/ffdecoder.py def terminate ( self ): \"\"\" Safely terminate all processes. \"\"\" # signal we are closing self . __verbose_logs and logger . debug ( \"Terminating FFdecoder Pipeline...\" ) self . __terminate_stream = True # Attempt to close pipeline. if self . __process is None or not ( self . __process . poll () is None ): return # no process was initiated at first place # close `stdin` output self . __process . stdin and self . __process . stdin . close () # close `stdout` output self . __process . stdout and self . __process . stdout . close () # wait if still process is still processing some information if self . __process . poll () is None : self . __process . terminate () self . __process . wait () self . __process = None","title":"API"},{"location":"reference/ffdecoder/#ffdecoder-api","text":"DeFFcode's FFdecoder API is a powerful real-time Video-frames Generator build on FFmpeg , that keeps on generating 3D 24-bit RGB (default) NumPy's ndarray frames from its pipeline with low-memory overhead continuously. FFdecoder supports a wide range of media stream such as any Video Input devices like USB Cameras, Multimedia video file format, Screen Captures, Image Sequences, plus any network stream URL (such as http(s), rtp, rstp, rtmp, mms, etc.) . FFdecoder API wraps FFmpeg pipeline inside a subprocess that run as completely independent entities and executes the pipeline concurrently with original process, extracting dataframes(in bytes) into NumPy's buffer(as a 1D array) from its stdout output. These dataframes are then converted into 3D NumPy's ndarray frames that are supported by almost all prominent Computer Vision libraries like OpenCV, Pytorch, dlib ,etc. and can be easily employed to perform various digital processing functions (like translation, rotation, resizing, cropping, fading, scaling) on-the-go. FFdecoder API can extract frames in real-time with any custom specification imaginable such as Framerate, Resolution, Hardware decoding, Complex Filters into any pixel format that FFmpeg supports along with desired parameters. Furthermore, This API also supports extraction of Source Metadata of all specified valid streams as Pretty JSON as well as its updation with user-defined dictionary. \u2009 For usage, kindly refer our Basic Recipes and Advanced Recipes FFdecoder API parameters are explained here \u27b6 Source code in deffcode/ffdecoder.py class FFdecoder : \"\"\" \"\"\" def __init__ ( self , source , frame_format = None , custom_ffmpeg = \"\" , verbose = False , ** extraparams ): \"\"\" This constructor method initializes the object state and attributes of the FFdecoder. Parameters: source (str): defines the default input source. frame_format (str): sets pixel format(-pix_fmt) of the decoded frames. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. verbose (bool): enables/disables verbose. extraparams (dict): provides the flexibility to control supported internal parameters and FFmpeg properties. \"\"\" # enable verbose if specified self . __verbose_logs = ( verbose if ( verbose and isinstance ( verbose , bool )) else False ) # define whether initializing self . __initializing = True # define frame pixel-format for decoded frames self . __frame_format = frame_format # handles user-defined parameters self . __extra_params = {} # handle process to be frames written self . __process = None # handle valid FFmpeg assets location self . __ffmpeg = \"\" # handle exclusive metadata self . __ff_pixfmt_metadata = None # metadata self . __raw_frame_num = None # raw-frame number self . __raw_frame_pixfmt = None # raw-frame pixformat self . __raw_frame_dtype = None # raw-frame dtype self . __raw_frame_depth = None # raw-frame depth self . __raw_frame_resolution = None # raw-frame resolution/dimension # define supported mode of operation self . __supported_opmodes = { \"av\" : \"Audio-Video\" , # audio is only for pass-through, not really for audio decoding yet. \"vo\" : \"Video-Only\" , \"imgseq\" : \"Image-Sequence\" , # \"ao\":\"Audio-Only\", # reserved for future } # operation mode variable self . __opmode = None # handle termination self . __terminate_stream = False # cleans and reformat user-defined parameters self . __extra_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in extraparams . items () } # handle custom Sourcer API params sourcer_params = self . __extra_params . pop ( \"-custom_sourcer_params\" , {}) # reset improper values sourcer_params = {} if not isinstance ( sourcer_params , dict ) else sourcer_params # pass parameter(if specified) to Sourcer API, specifying where to save the downloaded FFmpeg Static # assets on Windows(if specified) sourcer_params [ \"-ffmpeg_download_path\" ] = self . __extra_params . pop ( \"-ffmpeg_download_path\" , \"\" ) # handle video and audio stream indexes in case of multiple ones. default_stream_indexes = self . __extra_params . pop ( \"-default_stream_indexes\" , ( 0 , 0 ) ) # reset improper values default_stream_indexes = ( ( 0 , 0 ) if not isinstance ( default_stream_indexes , ( list , tuple )) else default_stream_indexes ) # extract and assign source metadata as dict self . __source_metadata = ( Sourcer ( source = source , verbose = verbose , ffmpeg_path = self . __ffmpeg , ** sourcer_params ) . probe_stream ( default_stream_indexes = default_stream_indexes ) . retrieve_metadata () ) # get valid ffmpeg path self . __ffmpeg = self . __source_metadata [ \"ffmpeg_binary_path\" ] # handle pass-through audio mode works in conjunction with WriteGear [WIP] self . __passthrough_mode = self . __extra_params . pop ( \"-passthrough_audio\" , False ) if not ( isinstance ( self . __passthrough_mode , bool )): self . __passthrough_mode = False # handle mode of operation if self . __source_metadata [ \"source_has_image_sequence\" ]: # image-sequence mode self . __opmode = \"imgseq\" elif ( self . __source_metadata [ \"source_has_video\" ] # audio is only for pass-through, not really for audio decoding yet. and self . __source_metadata [ \"source_has_audio\" ] and self . __passthrough_mode # [WIP] ): self . __opmode = \"av\" # elif __defop_mode == \"ao\" and self.__source_metadata.contains_audio: # [TODO] # self.__opmode = \"ao\" elif self . __source_metadata [ \"source_has_video\" ]: # video-only mode self . __opmode = \"vo\" else : # raise if unknown mode raise ValueError ( \"Unable to find suitable/usable video stream in the given source!\" ) # store as metadata self . __source_metadata [ \"ffdecoder_operational_mode\" ] = self . __supported_opmodes [ self . __opmode ] # and log it self . __verbose_logs and logger . critical ( \"Activating {} Mode of Operation.\" . format ( self . __supported_opmodes [ self . __opmode ] ) ) # handle user-defined framerate self . __inputframerate = self . __extra_params . pop ( \"-framerate\" , 0.0 ) if ( isinstance ( self . __inputframerate , ( float , int )) and self . __inputframerate > 0.0 ): # must be float self . __inputframerate = float ( self . __inputframerate ) else : # reset improper values self . __inputframerate = 0.0 # FFmpeg parameter `-s` is unsupported if not ( self . __extra_params . pop ( \"-s\" , None ) is None ): logger . warning ( \"Discarding user-defined `-s` FFmpeg parameter as it can only be assigned with `-custom_resolution`!\" ) # handle user defined decoded frame resolution(must be a tuple or list) self . __custom_resolution = self . __extra_params . pop ( \"-custom_resolution\" , None ) if self . __custom_resolution is None or not ( isinstance ( self . __custom_resolution , ( list , tuple )) and len ( self . __custom_resolution ) == 2 ): # reset improper values self . __custom_resolution = None # handle user defined ffmpeg pre-headers(parameters such as `-re`) parameters (must be a list) self . __ffmpeg_prefixes = self . __extra_params . pop ( \"-ffprefixes\" , []) if not isinstance ( self . __ffmpeg_prefixes , list ): # reset improper values self . __ffmpeg_prefixes = [] # handle user defined ffmpeg post-headers(parameters before `-i`) parameters (must be a list) self . __ffmpeg_postfixes = self . __extra_params . pop ( \"-ffpostfixes\" , []) if not isinstance ( self . __ffmpeg_postfixes , list ): # reset improper values self . __ffmpeg_postfixes = [] def formulate ( self ): \"\"\" Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. \"\"\" # assign values to class variables on first run if self . __initializing : # prepare parameter dict input_params = OrderedDict () output_params = OrderedDict () # dynamically pre-assign a default video-decoder (if not assigned by user). supported_vdecodecs = get_supported_vdecoders ( self . __ffmpeg ) default_vdecodec = ( self . __source_metadata [ \"source_video_decoder\" ] if self . __source_metadata [ \"source_video_decoder\" ] in supported_vdecodecs else \"unknown\" ) if \"-c:v\" in self . __extra_params : self . __extra_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-c:v\" , default_vdecodec ) # handle image sequence separately if self . __opmode == \"imgseq\" : # -vcodec is discarded by default # (This is correct or maybe -vcodec required in some unknown case) [TODO] self . __extra_params . pop ( \"-vcodec\" , None ) elif ( \"-vcodec\" in self . __extra_params and self . __extra_params [ \"-vcodec\" ] is None ): # special case when -vcodec is not needed intentionally self . __extra_params . pop ( \"-vcodec\" , None ) else : # assign video decoder selected here. if not \"-vcodec\" in self . __extra_params : input_params [ \"-vcodec\" ] = default_vdecodec else : input_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-vcodec\" , default_vdecodec ) if ( default_vdecodec != \"unknown\" and not input_params [ \"-vcodec\" ] in supported_vdecodecs ): # reset to default if not supported logger . warning ( \"Provided FFmpeg does not support ` {} ` video decoder. Switching to default supported ` {} ` decoder!\" . format ( input_params [ \"-vcodec\" ], default_vdecodec ) ) input_params [ \"-vcodec\" ] = default_vdecodec # raise error if not valid decoder found if not input_params [ \"-vcodec\" ] in supported_vdecodecs : raise RuntimeError ( \"Provided FFmpeg does not support any known usable video-decoders.\" \" Either define your own manually or switch to another FFmpeg binaries(if available).\" ) # handle user-defined number of frames. if \"-vframes\" in self . __extra_params : self . __extra_params [ \"-frames:v\" ] = self . __extra_params . pop ( \"-vframes\" , None ) if \"-frames:v\" in self . __extra_params : value = self . __extra_params . pop ( \"-frames:v\" , None ) if not ( value is None ) and value > 0 : output_params [ \"-frames:v\" ] = value # dynamically calculate raw-frame pixel format based on source (if not assigned by user). self . __ff_pixfmt_metadata = get_supported_pixfmts ( self . __ffmpeg ) supported_pixfmts = [ fmts [ 0 ] for fmts in self . __ff_pixfmt_metadata ] default_pixfmt = ( \"rgb24\" if \"rgb24\" in supported_pixfmts else self . __source_metadata [ \"source_video_pixfmt\" ] ) if \"-pix_fmt\" in self . __extra_params : logger . warning ( \"Discarding user-defined `-pix_fmt` value as it can only be assigned with `frame_format` parameter!\" ) self . __extra_params . pop ( \"-pix_fmt\" , None ) if ( self . __frame_format is None or not self . __frame_format in supported_pixfmts ): # reset to default if not supported not ( self . __frame_format is None ) and logger . critical ( \"Provided FFmpeg does not support ` {} ` pixel format(pix_fmt). Switching to default ` {} `!\" . format ( self . __frame_format , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt else : output_params [ \"-pix_fmt\" ] = self . __frame_format # dynamically calculate raw-frame dtype based on pix format selected frames_pixfmt = output_params [ \"-pix_fmt\" ] ( self . __raw_frame_depth , rawframesbpp ) = [ ( int ( x [ 1 ]), int ( x [ 2 ])) for x in self . __ff_pixfmt_metadata if x [ 0 ] == frames_pixfmt ][ 0 ] raw_bit_per_component = rawframesbpp // self . __raw_frame_depth if raw_bit_per_component in [ 4 , 8 ]: self . __raw_frame_dtype = np . dtype ( \"u1\" ) elif raw_bit_per_component == 16 : if frames_pixfmt . endswith ( \"le\" ): self . __raw_frame_dtype = np . dtype ( \"<u2\" ) elif frames_pixfmt . endswith ( \"be\" ): self . __raw_frame_dtype = np . dtype ( \">u2\" ) else : pass else : # reset to default if not supported logger . critical ( \"Given `frame_format` value: {} is not supported by FFdecoder. Switching to default ` {} `!\" . format ( frames_pixfmt , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt self . __raw_frame_dtype = np . dtype ( \"u1\" ) self . __raw_frame_pixfmt = output_params [ \"-pix_fmt\" ] # dynamically calculate raw-frame resolution/dimensions based on source (if not assigned by user). self . __raw_frame_resolution = ( self . __custom_resolution if not ( self . __custom_resolution is None ) else self . __source_metadata [ \"source_video_resolution\" ] ) dimensions = \" {} x {} \" . format ( self . __raw_frame_resolution [ 0 ], self . __raw_frame_resolution [ 1 ] ) # apply if defined output_params [ \"-s\" ] = str ( dimensions ) # dynamically calculate raw-frame frame-rate based on source (if not assigned by user). framerate = ( self . __inputframerate if self . __inputframerate > 0.0 else self . __source_metadata [ \"source_video_framerate\" ] ) output_params [ \"-framerate\" ] = str ( framerate ) # add rest to output parameters output_params . update ( self . __extra_params ) # dynamically calculate raw-frame numbers based on source (if not assigned by user). if \"-frames:v\" in input_params : self . __raw_frame_num = input_params [ \"-frames:v\" ] elif self . __source_metadata [ \"approx_video_nframes\" ]: self . __raw_frame_num = self . __source_metadata [ \"approx_video_nframes\" ] else : self . __raw_frame_num = None # log that number of frames are unknown self . __verbose_logs and logger . info ( \"Live/Network Stream detected! Number of frames for given source is unknown.\" ) # compose the Pipeline using formulated FFmpeg parameters self . __launch_FFdecoderline ( input_params , output_params ) # inform the initialization is completed self . __initializing = False else : # warn if pipeline is recreated logger . error ( \"This pipeline is already created and running!\" ) return self def __fetchNextfromPipeline ( self ): \"\"\" Internal method to fetch next dataframe(in bytes) from FFmpeg Pipeline. \"\"\" assert not ( self . __process is None ), \"Pipeline is not running! Check if you called `create()` method.\" # formulated raw frame size raw_frame_size = ( self . __raw_frame_depth * self . __raw_frame_resolution [ 0 ] * self . __raw_frame_resolution [ 1 ] ) # next dataframe as numpy ndarray nparray = None try : # read bytes frames from buffer nparray = np . frombuffer ( self . __process . stdout . read ( raw_frame_size * self . __raw_frame_dtype . itemsize ), dtype = self . __raw_frame_dtype , ) except Exception as e : raise RuntimeError ( \"Frame fetching failed with error: {} \" . format ( str ( e ))) return ( nparray if not ( nparray is None ) and len ( nparray ) == raw_frame_size else None ) def __fetchNextFrame ( self ): \"\"\" Internal method to reconstruct next video-frame(`ndarray`) from fetched dataframe. \"\"\" # Read next and reconstruct as numpy array frame = self . __fetchNextfromPipeline () # check if empty if frame is None : return frame elif self . __raw_frame_pixfmt . startswith ( \"gray\" ): # reconstruct gray frames frame = frame . reshape ( ( self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], self . __raw_frame_depth , ) )[:, :, 0 ] elif self . __raw_frame_pixfmt == \"yuv444p\" : # reconstruct exclusive frames frame = frame . reshape ( ( self . __raw_frame_depth , self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], ) ) . transpose (( 1 , 2 , 0 )) else : # reconstruct default frames frame = frame . reshape ( ( self . __raw_frame_resolution [ 1 ], self . __raw_frame_resolution [ 0 ], self . __raw_frame_depth , ) ) # return frame return frame def generateFrame ( self ): \"\"\" A python Generator function which can also works as an Iterator(using `next()`) for extracting video-frames(`ndarray`) at rapid pace. \"\"\" if self . __raw_frame_num is None or not self . __raw_frame_num : while not self . __terminate_stream : frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True continue yield frame else : for _ in range ( self . __raw_frame_num ): frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True break yield frame def __enter__ ( self ): \"\"\" Handles entry \"\"\" return self def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" Handles exit \"\"\" self . close () @property def metadata ( self ): \"\"\" A property object that dumps Source metadata dict as JSON for pretty printing. As well as can be used to update source metadata with user-defined dictionary. **Returns:** A [`json.dumps`](https://docs.python.org/3/library/json.html#json.dumps) output. \"\"\" return json . dumps ( self . __source_metadata , indent = 2 ) @metadata . setter def metadata ( self , value ): \"\"\" A property object that updates source metadata with user-defined dictionary. Parameters: value (dict): User-defined dictionary. \"\"\" self . __verbose_logs and logger . info ( \"Updating Metadata...\" ) if value and isinstance ( value , dict ): self . __source_metadata . update ( value ) else : raise ValueError ( \"Invalid value specified.\" ) def __launch_FFdecoderline ( self , input_params , output_params ): \"\"\" An Internal method that launches FFmpeg Pipeline using subprocess module, that pipelines dataframes(in bytes) to `stdout`. Parameters: input_params (dict): Input FFmpeg parameters output_params (dict): Output FFmpeg parameters \"\"\" # convert input parameters to list input_parameters = dict2Args ( input_params ) # convert output parameters to list output_parameters = dict2Args ( output_params ) # format command cmd = ( [ self . __ffmpeg ] + self . __ffmpeg_prefixes + input_parameters + self . __ffmpeg_postfixes + [ \"-i\" ] + [ self . __source_metadata [ \"source\" ]] + output_parameters + [ \"-f\" , \"rawvideo\" , \"-\" ] ) # assign value to class variable _cmd = \" \" . join ( cmd ) # compose the FFmpeg process if self . __verbose_logs : logger . debug ( \"Executing FFmpeg command: ` {} `\" . format ( _cmd )) # In debugging mode self . __process = sp . Popen ( cmd , stdin = sp . PIPE , stdout = sp . PIPE , stderr = None ) else : # In silent mode self . __process = sp . Popen ( cmd , stdin = sp . PIPE , stdout = sp . PIPE , stderr = sp . DEVNULL ) def terminate ( self ): \"\"\" Safely terminate all processes. \"\"\" # signal we are closing self . __verbose_logs and logger . debug ( \"Terminating FFdecoder Pipeline...\" ) self . __terminate_stream = True # Attempt to close pipeline. if self . __process is None or not ( self . __process . poll () is None ): return # no process was initiated at first place # close `stdin` output self . __process . stdin and self . __process . stdin . close () # close `stdout` output self . __process . stdout and self . __process . stdout . close () # wait if still process is still processing some information if self . __process . poll () is None : self . __process . terminate () self . __process . wait () self . __process = None","title":"FFdecoder API"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.metadata","text":"A property object that dumps Source metadata dict as JSON for pretty printing. As well as can be used to update source metadata with user-defined dictionary. Returns: A json.dumps output.","title":"metadata"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.__enter__","text":"Handles entry Source code in deffcode/ffdecoder.py def __enter__ ( self ): \"\"\" Handles entry \"\"\" return self","title":"__enter__()"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.__exit__","text":"Handles exit Source code in deffcode/ffdecoder.py def __exit__ ( self , exc_type , exc_val , exc_tb ): \"\"\" Handles exit \"\"\" self . close ()","title":"__exit__()"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.__init__","text":"This constructor method initializes the object state and attributes of the FFdecoder. Parameters: Name Type Description Default source str defines the default input source. required frame_format str sets pixel format(-pix_fmt) of the decoded frames. None custom_ffmpeg str assigns the location of custom path/directory for custom FFmpeg executable. '' verbose bool enables/disables verbose. False extraparams dict provides the flexibility to control supported internal parameters and FFmpeg properties. {} Source code in deffcode/ffdecoder.py def __init__ ( self , source , frame_format = None , custom_ffmpeg = \"\" , verbose = False , ** extraparams ): \"\"\" This constructor method initializes the object state and attributes of the FFdecoder. Parameters: source (str): defines the default input source. frame_format (str): sets pixel format(-pix_fmt) of the decoded frames. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. verbose (bool): enables/disables verbose. extraparams (dict): provides the flexibility to control supported internal parameters and FFmpeg properties. \"\"\" # enable verbose if specified self . __verbose_logs = ( verbose if ( verbose and isinstance ( verbose , bool )) else False ) # define whether initializing self . __initializing = True # define frame pixel-format for decoded frames self . __frame_format = frame_format # handles user-defined parameters self . __extra_params = {} # handle process to be frames written self . __process = None # handle valid FFmpeg assets location self . __ffmpeg = \"\" # handle exclusive metadata self . __ff_pixfmt_metadata = None # metadata self . __raw_frame_num = None # raw-frame number self . __raw_frame_pixfmt = None # raw-frame pixformat self . __raw_frame_dtype = None # raw-frame dtype self . __raw_frame_depth = None # raw-frame depth self . __raw_frame_resolution = None # raw-frame resolution/dimension # define supported mode of operation self . __supported_opmodes = { \"av\" : \"Audio-Video\" , # audio is only for pass-through, not really for audio decoding yet. \"vo\" : \"Video-Only\" , \"imgseq\" : \"Image-Sequence\" , # \"ao\":\"Audio-Only\", # reserved for future } # operation mode variable self . __opmode = None # handle termination self . __terminate_stream = False # cleans and reformat user-defined parameters self . __extra_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in extraparams . items () } # handle custom Sourcer API params sourcer_params = self . __extra_params . pop ( \"-custom_sourcer_params\" , {}) # reset improper values sourcer_params = {} if not isinstance ( sourcer_params , dict ) else sourcer_params # pass parameter(if specified) to Sourcer API, specifying where to save the downloaded FFmpeg Static # assets on Windows(if specified) sourcer_params [ \"-ffmpeg_download_path\" ] = self . __extra_params . pop ( \"-ffmpeg_download_path\" , \"\" ) # handle video and audio stream indexes in case of multiple ones. default_stream_indexes = self . __extra_params . pop ( \"-default_stream_indexes\" , ( 0 , 0 ) ) # reset improper values default_stream_indexes = ( ( 0 , 0 ) if not isinstance ( default_stream_indexes , ( list , tuple )) else default_stream_indexes ) # extract and assign source metadata as dict self . __source_metadata = ( Sourcer ( source = source , verbose = verbose , ffmpeg_path = self . __ffmpeg , ** sourcer_params ) . probe_stream ( default_stream_indexes = default_stream_indexes ) . retrieve_metadata () ) # get valid ffmpeg path self . __ffmpeg = self . __source_metadata [ \"ffmpeg_binary_path\" ] # handle pass-through audio mode works in conjunction with WriteGear [WIP] self . __passthrough_mode = self . __extra_params . pop ( \"-passthrough_audio\" , False ) if not ( isinstance ( self . __passthrough_mode , bool )): self . __passthrough_mode = False # handle mode of operation if self . __source_metadata [ \"source_has_image_sequence\" ]: # image-sequence mode self . __opmode = \"imgseq\" elif ( self . __source_metadata [ \"source_has_video\" ] # audio is only for pass-through, not really for audio decoding yet. and self . __source_metadata [ \"source_has_audio\" ] and self . __passthrough_mode # [WIP] ): self . __opmode = \"av\" # elif __defop_mode == \"ao\" and self.__source_metadata.contains_audio: # [TODO] # self.__opmode = \"ao\" elif self . __source_metadata [ \"source_has_video\" ]: # video-only mode self . __opmode = \"vo\" else : # raise if unknown mode raise ValueError ( \"Unable to find suitable/usable video stream in the given source!\" ) # store as metadata self . __source_metadata [ \"ffdecoder_operational_mode\" ] = self . __supported_opmodes [ self . __opmode ] # and log it self . __verbose_logs and logger . critical ( \"Activating {} Mode of Operation.\" . format ( self . __supported_opmodes [ self . __opmode ] ) ) # handle user-defined framerate self . __inputframerate = self . __extra_params . pop ( \"-framerate\" , 0.0 ) if ( isinstance ( self . __inputframerate , ( float , int )) and self . __inputframerate > 0.0 ): # must be float self . __inputframerate = float ( self . __inputframerate ) else : # reset improper values self . __inputframerate = 0.0 # FFmpeg parameter `-s` is unsupported if not ( self . __extra_params . pop ( \"-s\" , None ) is None ): logger . warning ( \"Discarding user-defined `-s` FFmpeg parameter as it can only be assigned with `-custom_resolution`!\" ) # handle user defined decoded frame resolution(must be a tuple or list) self . __custom_resolution = self . __extra_params . pop ( \"-custom_resolution\" , None ) if self . __custom_resolution is None or not ( isinstance ( self . __custom_resolution , ( list , tuple )) and len ( self . __custom_resolution ) == 2 ): # reset improper values self . __custom_resolution = None # handle user defined ffmpeg pre-headers(parameters such as `-re`) parameters (must be a list) self . __ffmpeg_prefixes = self . __extra_params . pop ( \"-ffprefixes\" , []) if not isinstance ( self . __ffmpeg_prefixes , list ): # reset improper values self . __ffmpeg_prefixes = [] # handle user defined ffmpeg post-headers(parameters before `-i`) parameters (must be a list) self . __ffmpeg_postfixes = self . __extra_params . pop ( \"-ffpostfixes\" , []) if not isinstance ( self . __ffmpeg_postfixes , list ): # reset improper values self . __ffmpeg_postfixes = []","title":"__init__()"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.formulate","text":"Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. Source code in deffcode/ffdecoder.py def formulate ( self ): \"\"\" Formulates all necessary FFmpeg parameters command and Launches FFmpeg Pipeline using subprocess module. \"\"\" # assign values to class variables on first run if self . __initializing : # prepare parameter dict input_params = OrderedDict () output_params = OrderedDict () # dynamically pre-assign a default video-decoder (if not assigned by user). supported_vdecodecs = get_supported_vdecoders ( self . __ffmpeg ) default_vdecodec = ( self . __source_metadata [ \"source_video_decoder\" ] if self . __source_metadata [ \"source_video_decoder\" ] in supported_vdecodecs else \"unknown\" ) if \"-c:v\" in self . __extra_params : self . __extra_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-c:v\" , default_vdecodec ) # handle image sequence separately if self . __opmode == \"imgseq\" : # -vcodec is discarded by default # (This is correct or maybe -vcodec required in some unknown case) [TODO] self . __extra_params . pop ( \"-vcodec\" , None ) elif ( \"-vcodec\" in self . __extra_params and self . __extra_params [ \"-vcodec\" ] is None ): # special case when -vcodec is not needed intentionally self . __extra_params . pop ( \"-vcodec\" , None ) else : # assign video decoder selected here. if not \"-vcodec\" in self . __extra_params : input_params [ \"-vcodec\" ] = default_vdecodec else : input_params [ \"-vcodec\" ] = self . __extra_params . pop ( \"-vcodec\" , default_vdecodec ) if ( default_vdecodec != \"unknown\" and not input_params [ \"-vcodec\" ] in supported_vdecodecs ): # reset to default if not supported logger . warning ( \"Provided FFmpeg does not support ` {} ` video decoder. Switching to default supported ` {} ` decoder!\" . format ( input_params [ \"-vcodec\" ], default_vdecodec ) ) input_params [ \"-vcodec\" ] = default_vdecodec # raise error if not valid decoder found if not input_params [ \"-vcodec\" ] in supported_vdecodecs : raise RuntimeError ( \"Provided FFmpeg does not support any known usable video-decoders.\" \" Either define your own manually or switch to another FFmpeg binaries(if available).\" ) # handle user-defined number of frames. if \"-vframes\" in self . __extra_params : self . __extra_params [ \"-frames:v\" ] = self . __extra_params . pop ( \"-vframes\" , None ) if \"-frames:v\" in self . __extra_params : value = self . __extra_params . pop ( \"-frames:v\" , None ) if not ( value is None ) and value > 0 : output_params [ \"-frames:v\" ] = value # dynamically calculate raw-frame pixel format based on source (if not assigned by user). self . __ff_pixfmt_metadata = get_supported_pixfmts ( self . __ffmpeg ) supported_pixfmts = [ fmts [ 0 ] for fmts in self . __ff_pixfmt_metadata ] default_pixfmt = ( \"rgb24\" if \"rgb24\" in supported_pixfmts else self . __source_metadata [ \"source_video_pixfmt\" ] ) if \"-pix_fmt\" in self . __extra_params : logger . warning ( \"Discarding user-defined `-pix_fmt` value as it can only be assigned with `frame_format` parameter!\" ) self . __extra_params . pop ( \"-pix_fmt\" , None ) if ( self . __frame_format is None or not self . __frame_format in supported_pixfmts ): # reset to default if not supported not ( self . __frame_format is None ) and logger . critical ( \"Provided FFmpeg does not support ` {} ` pixel format(pix_fmt). Switching to default ` {} `!\" . format ( self . __frame_format , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt else : output_params [ \"-pix_fmt\" ] = self . __frame_format # dynamically calculate raw-frame dtype based on pix format selected frames_pixfmt = output_params [ \"-pix_fmt\" ] ( self . __raw_frame_depth , rawframesbpp ) = [ ( int ( x [ 1 ]), int ( x [ 2 ])) for x in self . __ff_pixfmt_metadata if x [ 0 ] == frames_pixfmt ][ 0 ] raw_bit_per_component = rawframesbpp // self . __raw_frame_depth if raw_bit_per_component in [ 4 , 8 ]: self . __raw_frame_dtype = np . dtype ( \"u1\" ) elif raw_bit_per_component == 16 : if frames_pixfmt . endswith ( \"le\" ): self . __raw_frame_dtype = np . dtype ( \"<u2\" ) elif frames_pixfmt . endswith ( \"be\" ): self . __raw_frame_dtype = np . dtype ( \">u2\" ) else : pass else : # reset to default if not supported logger . critical ( \"Given `frame_format` value: {} is not supported by FFdecoder. Switching to default ` {} `!\" . format ( frames_pixfmt , \"rgb24\" ) ) output_params [ \"-pix_fmt\" ] = default_pixfmt self . __raw_frame_dtype = np . dtype ( \"u1\" ) self . __raw_frame_pixfmt = output_params [ \"-pix_fmt\" ] # dynamically calculate raw-frame resolution/dimensions based on source (if not assigned by user). self . __raw_frame_resolution = ( self . __custom_resolution if not ( self . __custom_resolution is None ) else self . __source_metadata [ \"source_video_resolution\" ] ) dimensions = \" {} x {} \" . format ( self . __raw_frame_resolution [ 0 ], self . __raw_frame_resolution [ 1 ] ) # apply if defined output_params [ \"-s\" ] = str ( dimensions ) # dynamically calculate raw-frame frame-rate based on source (if not assigned by user). framerate = ( self . __inputframerate if self . __inputframerate > 0.0 else self . __source_metadata [ \"source_video_framerate\" ] ) output_params [ \"-framerate\" ] = str ( framerate ) # add rest to output parameters output_params . update ( self . __extra_params ) # dynamically calculate raw-frame numbers based on source (if not assigned by user). if \"-frames:v\" in input_params : self . __raw_frame_num = input_params [ \"-frames:v\" ] elif self . __source_metadata [ \"approx_video_nframes\" ]: self . __raw_frame_num = self . __source_metadata [ \"approx_video_nframes\" ] else : self . __raw_frame_num = None # log that number of frames are unknown self . __verbose_logs and logger . info ( \"Live/Network Stream detected! Number of frames for given source is unknown.\" ) # compose the Pipeline using formulated FFmpeg parameters self . __launch_FFdecoderline ( input_params , output_params ) # inform the initialization is completed self . __initializing = False else : # warn if pipeline is recreated logger . error ( \"This pipeline is already created and running!\" ) return self","title":"formulate()"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.generateFrame","text":"A python Generator function which can also works as an Iterator(using next() ) for extracting video-frames( ndarray ) at rapid pace. Source code in deffcode/ffdecoder.py def generateFrame ( self ): \"\"\" A python Generator function which can also works as an Iterator(using `next()`) for extracting video-frames(`ndarray`) at rapid pace. \"\"\" if self . __raw_frame_num is None or not self . __raw_frame_num : while not self . __terminate_stream : frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True continue yield frame else : for _ in range ( self . __raw_frame_num ): frame = self . __fetchNextFrame () if frame is None : self . __terminate_stream = True break yield frame","title":"generateFrame()"},{"location":"reference/ffdecoder/#deffcode.ffdecoder.FFdecoder.terminate","text":"Safely terminate all processes. Source code in deffcode/ffdecoder.py def terminate ( self ): \"\"\" Safely terminate all processes. \"\"\" # signal we are closing self . __verbose_logs and logger . debug ( \"Terminating FFdecoder Pipeline...\" ) self . __terminate_stream = True # Attempt to close pipeline. if self . __process is None or not ( self . __process . poll () is None ): return # no process was initiated at first place # close `stdin` output self . __process . stdin and self . __process . stdin . close () # close `stdout` output self . __process . stdout and self . __process . stdout . close () # wait if still process is still processing some information if self . __process . poll () is None : self . __process . terminate () self . __process . wait () self . __process = None","title":"terminate()"},{"location":"reference/ffdecoder/params/","text":"FFdecoder API Parameters \u00b6 source \u00b6 FFdecoder API will throw RuntimeError if source provided is invalid or missing. This parameter defines the default input source. Data-Type: String. Its valid input can be one of the following: Filepath: Valid path of the video file, for e.g \"/home/foo.mp4\" as follows: Multiple video file paths are not yet support! decoder = FFdecoder ( '/home/foo.mp4' ) . formulate () Image Sequence: Valid image sequence such as sequential 'img%03d.png' or '*.png' glob pattern or even single(loop) image as input: Sequential Glob pattern Single image # initialize and formulate the decoder decoder = FFdecoder ( 'img %03d .png' ) . formulate () You can use -start_number FFmpeg parameter if you want to start with specific number: # define `-start_number` such as `5` extraparams = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img %03d .png' , verbose = True , ** extraparams ) . formulate () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. You can do it as follows: The glob pattern is not available on Windows builds. # define `-pattern_type glob` for accepting glob pattern extraparams = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img*.png' , verbose = True , ** extraparams ) . formulate () You can use a single looping image as follows: # define `-loop 1` for looping extraparams = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img.jpg' , verbose = True , ** extraparams ) . formulate () Network Address: Valid ( http(s) , rtp , rstp , rtmp , mms , etc.) incoming network stream address such as 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' as input: # define `rtsp_transport` or necessary parameters extraparams = { \"-ffpostfixes\" :[ \"-rtsp_transport\" , \"tcp\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' , verbose = True , ** extraparams ) . formulate () Video Input devices: (Yet to be supported) Screen Capture: (Yet to be supported) frame_format \u00b6 This parameter select pixel format of the output frames, such as gray for grayscale output. If not specified, its value is defaults to rgb24 (24-bit RGB) . Any invalid or unsupported value to frame_format parameter will discarded! Supported Decoders All the pixel formats that are compiled with FFmpeg in use, are supported by FFdecoder API. You can easily check the compiled pixel formats by running following command in your terminal: # for checking pixel formats ffmpeg -pix_fmts # use `ffmpeg.exe -pix_fmts` on windows Data-Type: String Default Value: Its default value is rgb24 Usage: # initialize and formulate the decoder for grayscale frames decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"gray\" ) . formulate () custom_ffmpeg \u00b6 This parameter assigns the custom path/directory where the custom/downloaded FFmpeg executables are located. Behavior on Windows If a custom FFmpeg executable's path | directory is not provided through custom_ffmpeg parameter on Windows machine, then FFdecoder API will automatically attempt to download and extract suitable Static FFmpeg binaries at suitable location on your windows machine . More information can be found here \u27b6 . Data-Type: String Default Value: Its default value is None . Usage: # If ffmpeg executables are located at \"/foo/foo1/ffmpeg\" FFdecoder ( \"foo.mp4\" , custom_ffmpeg = \"/foo/foo1/ffmpeg\" ) . formulate () verbose \u00b6 This parameter enables verbose (if True ) , essential for debugging. Data-Type: Boolean Default Value: Its default value is False . Usage: FFdecoder ( \"foo.mp4\" , verbose = True ) . formulate () extraparams \u00b6 This parameter accepts to all supported parameters formatted as as its attributes: Kindly read FFmpeg Docs carefully before passing any additional values to extraparams parameter. Wrong invalid values may result in undesired errors or no output at all. Data-Type: Dictionary Default Value: Its default value is {} . Supported Parameters \u00b6 A. FFmpeg Parameters \u00b6 Almost any FFmpeg parameter (supported by installed FFmpeg) can be passed as dictionary attributes in extraparams . But make sure to read FFmpeg Docs carefully first. Let's assume we're using h264_nvenc NVDEC/CUVID decoder to produce faster frames with low memory footprints, then we can pass required FFmpeg parameters as dictionary attributes as follows: Kindly check NVDEC/CUVID doc \u27b6 and other FFmpeg Docs \u27b6 for more information on these parameters All ffmpeg parameters are case-sensitive. Remember to double check every parameter if any error occurs. extraparams = { \"-vcodec\" : \"h264_nvenc\" , \"-ffpostfixes\" :[ \"-hwaccel\" , \"cuda\" , \"-hwaccel_output_format\" , \"cuda\" ]} \u2009 B. Exclusive Parameters \u00b6 In addition to FFmpeg parameters, FFdecoder API also supports few Exclusive Parameters to flexibly alter its internal properties as well as handle some special FFmpeg parameters. These parameters are discussed below: -vcodec (str) : works similiar to -vcodec FFmpeg parameter for specifying supported decoders . If not specified, it derived from source video. Its usage is as follows: To remove -vcodec forcefully from FFmpeg Pipeline, assign its value Nonetype as { \"-vcodec\" : None } in extraparams extraparams = { \"-vcodec\" : \"h264\" } # set decoder to `h264` \u2002 -framerate (float/int) : works similiar to -framerate FFmpeg parameter for generating video-frames at specified framerate. If not specified, it calculated from source video framerate. Its usage is as follows: extraparams = { \"-framerate\" : 60.0 } # set input video source framerate to 60fps \u2002 -custom_resolution (tuple/list) : sets the custom resolution/size/dimensions of the output frames. Its value can either be a tuple => (width,height) or a list => [width, height] . If not specified, it calculated from source video resolution. Its usage is as follows: extraparams = { \"-output_dimensions\" : ( 1280 , 720 )} # to produce a 1280x720 resolution/scale output video \u2002 -ffprefixes (list) : sets the special FFmpeg parameters(at the beginning) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -ffpostfixes and -clones All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-ffprefixes\" : [ '-re' ]} # executes as `ffmpeg -re <rest of command>` \u2002 -ffpostfixes (list) : sets the special FFmpeg parameters(in the middle) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -clones and -ffprefixes All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-ffpostfixes\" : [ '-preset' , 'fast' ]} # executes as `ffmpeg -vcodec h264 -preset fast <rest of command>` \u2002 -clones (list) : sets the special FFmpeg parameters(at the end) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -ffpostfixes and -ffprefixes All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-clones\" : [ '-map' , '0:v:0' , '-map' , '1:a?' ]} # executes as `ffmpeg -vcodec -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25.0 -map 0:v:0 -map 1:a -f rawvideo - \u2002 -custom_sourcer_params (dict) : assigns values to Sourcer API's source_params dictionary parameter directly through FFdecoder API. Its usage is as follows: extraparams = { \"-custom_sourcer_params\" : { \"-ffmpeg_download_path\" : \"C:/User/foo/foo1\" }} # will be assigned to Sourcer API's `source_params` directly \u2002 -passthrough_audio (bool/list) : (Yet to be supported) \u2002 Supported Decoders \u00b6 All the decoders that are compiled with FFmpeg in use, are supported by FFdecoder API. You can easily check the compiled decoders by running following command in your terminal: # for checking decoders ffmpeg -decoders # use `ffmpeg.exe -decoders` on windows","title":"API Parameters"},{"location":"reference/ffdecoder/params/#ffdecoder-api-parameters","text":"","title":"FFdecoder API Parameters"},{"location":"reference/ffdecoder/params/#source","text":"FFdecoder API will throw RuntimeError if source provided is invalid or missing. This parameter defines the default input source. Data-Type: String. Its valid input can be one of the following: Filepath: Valid path of the video file, for e.g \"/home/foo.mp4\" as follows: Multiple video file paths are not yet support! decoder = FFdecoder ( '/home/foo.mp4' ) . formulate () Image Sequence: Valid image sequence such as sequential 'img%03d.png' or '*.png' glob pattern or even single(loop) image as input: Sequential Glob pattern Single image # initialize and formulate the decoder decoder = FFdecoder ( 'img %03d .png' ) . formulate () You can use -start_number FFmpeg parameter if you want to start with specific number: # define `-start_number` such as `5` extraparams = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img %03d .png' , verbose = True , ** extraparams ) . formulate () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. You can do it as follows: The glob pattern is not available on Windows builds. # define `-pattern_type glob` for accepting glob pattern extraparams = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img*.png' , verbose = True , ** extraparams ) . formulate () You can use a single looping image as follows: # define `-loop 1` for looping extraparams = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'img.jpg' , verbose = True , ** extraparams ) . formulate () Network Address: Valid ( http(s) , rtp , rstp , rtmp , mms , etc.) incoming network stream address such as 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' as input: # define `rtsp_transport` or necessary parameters extraparams = { \"-ffpostfixes\" :[ \"-rtsp_transport\" , \"tcp\" ]} # initialize and formulate the decoder with define parameters decoder = FFdecoder ( 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' , verbose = True , ** extraparams ) . formulate () Video Input devices: (Yet to be supported) Screen Capture: (Yet to be supported)","title":"source"},{"location":"reference/ffdecoder/params/#frame_format","text":"This parameter select pixel format of the output frames, such as gray for grayscale output. If not specified, its value is defaults to rgb24 (24-bit RGB) . Any invalid or unsupported value to frame_format parameter will discarded! Supported Decoders All the pixel formats that are compiled with FFmpeg in use, are supported by FFdecoder API. You can easily check the compiled pixel formats by running following command in your terminal: # for checking pixel formats ffmpeg -pix_fmts # use `ffmpeg.exe -pix_fmts` on windows Data-Type: String Default Value: Its default value is rgb24 Usage: # initialize and formulate the decoder for grayscale frames decoder = FFdecoder ( \"foo.mp4\" , frame_format = \"gray\" ) . formulate ()","title":"frame_format"},{"location":"reference/ffdecoder/params/#custom_ffmpeg","text":"This parameter assigns the custom path/directory where the custom/downloaded FFmpeg executables are located. Behavior on Windows If a custom FFmpeg executable's path | directory is not provided through custom_ffmpeg parameter on Windows machine, then FFdecoder API will automatically attempt to download and extract suitable Static FFmpeg binaries at suitable location on your windows machine . More information can be found here \u27b6 . Data-Type: String Default Value: Its default value is None . Usage: # If ffmpeg executables are located at \"/foo/foo1/ffmpeg\" FFdecoder ( \"foo.mp4\" , custom_ffmpeg = \"/foo/foo1/ffmpeg\" ) . formulate ()","title":"custom_ffmpeg"},{"location":"reference/ffdecoder/params/#verbose","text":"This parameter enables verbose (if True ) , essential for debugging. Data-Type: Boolean Default Value: Its default value is False . Usage: FFdecoder ( \"foo.mp4\" , verbose = True ) . formulate ()","title":"verbose"},{"location":"reference/ffdecoder/params/#extraparams","text":"This parameter accepts to all supported parameters formatted as as its attributes: Kindly read FFmpeg Docs carefully before passing any additional values to extraparams parameter. Wrong invalid values may result in undesired errors or no output at all. Data-Type: Dictionary Default Value: Its default value is {} .","title":"extraparams"},{"location":"reference/ffdecoder/params/#supported-parameters","text":"","title":"Supported Parameters"},{"location":"reference/ffdecoder/params/#a-ffmpeg-parameters","text":"Almost any FFmpeg parameter (supported by installed FFmpeg) can be passed as dictionary attributes in extraparams . But make sure to read FFmpeg Docs carefully first. Let's assume we're using h264_nvenc NVDEC/CUVID decoder to produce faster frames with low memory footprints, then we can pass required FFmpeg parameters as dictionary attributes as follows: Kindly check NVDEC/CUVID doc \u27b6 and other FFmpeg Docs \u27b6 for more information on these parameters All ffmpeg parameters are case-sensitive. Remember to double check every parameter if any error occurs. extraparams = { \"-vcodec\" : \"h264_nvenc\" , \"-ffpostfixes\" :[ \"-hwaccel\" , \"cuda\" , \"-hwaccel_output_format\" , \"cuda\" ]}","title":"A. FFmpeg Parameters"},{"location":"reference/ffdecoder/params/#b-exclusive-parameters","text":"In addition to FFmpeg parameters, FFdecoder API also supports few Exclusive Parameters to flexibly alter its internal properties as well as handle some special FFmpeg parameters. These parameters are discussed below: -vcodec (str) : works similiar to -vcodec FFmpeg parameter for specifying supported decoders . If not specified, it derived from source video. Its usage is as follows: To remove -vcodec forcefully from FFmpeg Pipeline, assign its value Nonetype as { \"-vcodec\" : None } in extraparams extraparams = { \"-vcodec\" : \"h264\" } # set decoder to `h264` \u2002 -framerate (float/int) : works similiar to -framerate FFmpeg parameter for generating video-frames at specified framerate. If not specified, it calculated from source video framerate. Its usage is as follows: extraparams = { \"-framerate\" : 60.0 } # set input video source framerate to 60fps \u2002 -custom_resolution (tuple/list) : sets the custom resolution/size/dimensions of the output frames. Its value can either be a tuple => (width,height) or a list => [width, height] . If not specified, it calculated from source video resolution. Its usage is as follows: extraparams = { \"-output_dimensions\" : ( 1280 , 720 )} # to produce a 1280x720 resolution/scale output video \u2002 -ffprefixes (list) : sets the special FFmpeg parameters(at the beginning) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -ffpostfixes and -clones All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-ffprefixes\" : [ '-re' ]} # executes as `ffmpeg -re <rest of command>` \u2002 -ffpostfixes (list) : sets the special FFmpeg parameters(in the middle) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -clones and -ffprefixes All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-ffpostfixes\" : [ '-preset' , 'fast' ]} # executes as `ffmpeg -vcodec h264 -preset fast <rest of command>` \u2002 -clones (list) : sets the special FFmpeg parameters(at the end) that are repeated more than once or occurs in a specific order in the FFmpeg command. Its value can be of datatype list only and its usage is as follows: This parameter is different from -ffpostfixes and -ffprefixes All three -clones , -ffpostfixes , and -ffprefixes parameters even tho fundamentally work the same, they're meant to serve at different places in the FFmpeg command. Normally, FFdecoder API pipeline looks something like following with all three parameters in place: ffmpeg {{ -ffprefixes FFmpeg params }} -vcodec h264 {{ -ffpostfixes FFmpeg params }} -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25 .0 {{ -clones FFmpeg params }} -f rawvideo - Turn on verbose( verbose = True ) to see the FFmpeg command that is being executed in FFdecoder's pipeline. This helps you debug/address any issues and make adjustments accordingly. extraparams = { \"-clones\" : [ '-map' , '0:v:0' , '-map' , '1:a?' ]} # executes as `ffmpeg -vcodec -i foo.mp4 -pix_fmt rgb24 -s 1280x720 -framerate 25.0 -map 0:v:0 -map 1:a -f rawvideo - \u2002 -custom_sourcer_params (dict) : assigns values to Sourcer API's source_params dictionary parameter directly through FFdecoder API. Its usage is as follows: extraparams = { \"-custom_sourcer_params\" : { \"-ffmpeg_download_path\" : \"C:/User/foo/foo1\" }} # will be assigned to Sourcer API's `source_params` directly \u2002 -passthrough_audio (bool/list) : (Yet to be supported)","title":"B. Exclusive Parameters"},{"location":"reference/ffdecoder/params/#supported-decoders","text":"All the decoders that are compiled with FFmpeg in use, are supported by FFdecoder API. You can easily check the compiled decoders by running following command in your terminal: # for checking decoders ffmpeg -decoders # use `ffmpeg.exe -decoders` on windows","title":"Supported Decoders"},{"location":"reference/sourcer/","text":"Sourcer API \u00b6 DeFFcode's Sourcer API acts as Source Validator and Classifier (just like talent sourcer ) for its FFdecoder API . This API parses FFmpeg's subprocess output for a given source and uses it to validate and identify all valid streams available in it. Sourcer API also acts as a Metadata Extraction Tool that extracts metadata of all specified valid streams that FFdecoder API uses for formatting its default FFmpeg pipeline for frames generation. Furthermore, Sourcer is responsible for validating FFmpeg executable path for DeFFcode. Extracting Source Video Metadata in DeFFcode Metadata can be easily extracted as a dictionary in Sourcer API using its retrieve_metadata() method. However, you can also use metadata property object in FFdecoder API to extract metadata as Pretty JSON, and update it directly as desired. More information can be found in this usage example \u27b6 . All parameter available with Sourcer API extracted as python dictionary(On Windows), are as follows: { \"ffmpeg_binary_path\" : \"C: \\\\ Users \\\\ foo \\\\ AppData \\\\ Local \\\\ Temp \\\\ ffmpeg-static-win64-gpl/bin/ffmpeg.exe\" , \"source\" : \"foo.mp4\" , \"source_extension\" : \".mp4\" , \"source_video_resolution\" : [ 1280 , 720 ], \"source_video_framerate\" : 25.0 , \"source_video_pixfmt\" : \"yuv420p\" , \"source_video_decoder\" : \"h264\" , \"source_duration_sec\" : 5.31 , \"approx_video_nframes\" : 133 , \"source_video_bitrate\" : \"1205k\" , \"source_audio_bitrate\" : \"384k\" , \"source_audio_samplerate\" : \"48000 Hz\" , \"source_has_video\" : True , \"source_has_audio\" : True , \"source_has_image_sequence\" : False , } \u2009 For usage, kindly refer our Basic Recipes and Advanced Recipes Sourcer API parameters are explained here \u27b6 Source code in deffcode/sourcer.py class Sourcer : \"\"\" \"\"\" def __init__ ( self , source , custom_ffmpeg = \"\" , verbose = False , ** sourcer_params ): \"\"\" This constructor method initializes the object state and attributes of the Sourcer. Parameters: source (str): defines the default input source. verbose (bool): enables/disables verbose. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. sourcer_params (dict): provides the flexibility to control supported internal Sourcer parameters. \"\"\" # checks if machine in-use is running windows os or not self . __os_windows = True if os . name == \"nt\" else False # define internal parameters self . __verbose_logs = ( # enable verbose if specified verbose if ( verbose and isinstance ( verbose , bool )) else False ) self . __ffsp_output = None # handles metadata received self . __sourcer_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in sourcer_params . items () } # handle whether to force validate source self . __forcevalidatesource = self . __sourcer_params . pop ( \"-force_validate_source\" , False ) if not isinstance ( self . __forcevalidatesource , bool ): # reset improper values self . __forcevalidatesource = False # handle where to save the downloaded FFmpeg Static assets on Windows(if specified) __ffmpeg_download_path = self . __sourcer_params . pop ( \"-ffmpeg_download_path\" , \"\" ) if not isinstance ( __ffmpeg_download_path , str ): # reset improper values __ffmpeg_download_path = \"\" # validate the FFmpeg assets and return location (also downloads static assets on windows) self . __ffmpeg = get_valid_ffmpeg_path ( str ( custom_ffmpeg ), self . __os_windows , ffmpeg_download_path = __ffmpeg_download_path , verbose = self . __verbose_logs , ) # check if valid FFmpeg path returned if self . __ffmpeg : self . __verbose_logs and logger . debug ( \"Found valid FFmpeg executable: ` {} `.\" . format ( self . __ffmpeg ) ) else : # else raise error raise RuntimeError ( \"[DeFFcode:ERROR] :: Failed to find FFmpeg assets on this system. Kindly compile/install FFmpeg or provide a valid custom FFmpeg binary path!\" ) # define externally accessible parameters self . __source = source # handles source stream self . __source_extension = os . path . splitext ( source )[ - 1 ] # handles source stream extension self . __default_video_resolution = \"\" # handle stream resolution self . __default_video_framerate = \"\" # handle stream framerate self . __default_video_bitrate = \"\" # handle stream's video bitrate self . __default_video_pixfmt = \"\" # handle stream's video pixfmt self . __default_video_decoder = \"\" # handle stream's video decoder self . __default_source_duration = \"\" # handle stream's video duration self . __approx_video_nframes = \"\" # handle approx stream frame number self . __default_audio_bitrate = \"\" # handle stream's audio bitrate self . __default_audio_samplerate = \"\" # handle stream's audio samplerate # handle flags self . __contains_video = False # contain video self . __contains_audio = False # contain audio self . __contains_images = False # contain image-sequence # check whether metadata probed or not self . __metadata_probed = False def probe_stream ( self , default_stream_indexes = ( 0 , 0 )): \"\"\" Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: default_stream_indexes (list, tuple): selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0th video stream\", \"1st audio stream\"). **Returns:** Reference to the instance object. \"\"\" assert ( isinstance ( default_stream_indexes , ( list , tuple )) and len ( default_stream_indexes ) == 2 and all ( isinstance ( x , int ) for x in default_stream_indexes ) ), \"Invalid default_stream_indexes value!\" # validate source and extract metadata self . __ffsp_output = self . __validate_source ( self . __source ) # parse resolution and framerate video_rfparams = self . __extract_resolution_framerate ( default_stream = default_stream_indexes [ 0 ] ) if video_rfparams : self . __default_video_resolution = video_rfparams [ \"resolution\" ] self . __default_video_framerate = video_rfparams [ \"framerate\" ] # parse pixel format self . __default_video_pixfmt = self . __extract_video_pixfmt ( default_stream = default_stream_indexes [ 0 ] ) # parse video decoder self . __default_video_decoder = self . __extract_video_decoder ( default_stream = default_stream_indexes [ 0 ] ) # parse rest of metadata if not self . __contains_images : # parse video bitrate self . __default_video_bitrate = self . __extract_video_bitrate ( default_stream = default_stream_indexes [ 0 ] ) # parse audio bitrate and samplerate audio_params = self . __extract_audio_bitrate_nd_samplerate ( default_stream = default_stream_indexes [ 1 ] ) if audio_params : self . __default_audio_bitrate = audio_params [ \"bitrate\" ] self . __default_audio_samplerate = audio_params [ \"samplerate\" ] # parse video duration self . __default_source_duration = self . __extract_duration () # calculate all flags if ( self . __default_video_bitrate or self . __default_video_framerate ) and ( self . __default_audio_bitrate or self . __default_audio_samplerate ): self . __contains_video = True self . __contains_audio = True elif self . __default_video_bitrate or self . __default_video_framerate : self . __contains_video = True elif self . __default_audio_bitrate or self . __default_audio_samplerate : self . __contains_audio = True else : raise IOError ( \"Invalid source provided. No usable Audio/Video stream detected. Aborting!!!\" ) # calculate approximate number of video frame if self . __default_video_framerate and self . __default_source_duration : self . __approx_video_nframes = np . rint ( self . __default_video_framerate * self . __default_source_duration ) . astype ( int , casting = \"unsafe\" ) # signal metadata has been probed self . __metadata_probed = True # return reference to the instance object. return self def retrieve_metadata ( self ): \"\"\" Returns Source metadata formatted as python dictionary. **Returns:** A dictionary value containing metadata. \"\"\" # check if metadata has been probed or not assert ( self . __metadata_probed ), \"Source Metadata not been probed yet! Check if you called `probe_stream()` method.\" self . __verbose_logs and logger . debug ( \"Retrieving Metadata...\" ) metadata = { \"ffmpeg_binary_path\" : self . __ffmpeg , \"source\" : self . __source , \"source_extension\" : self . __source_extension , \"source_video_resolution\" : self . __default_video_resolution , \"source_video_framerate\" : self . __default_video_framerate , \"source_video_pixfmt\" : self . __default_video_pixfmt , \"source_video_decoder\" : self . __default_video_decoder , \"source_duration_sec\" : self . __default_source_duration , \"approx_video_nframes\" : int ( self . __approx_video_nframes ) if self . __approx_video_nframes else None , \"source_video_bitrate\" : self . __default_video_bitrate , \"source_audio_bitrate\" : self . __default_audio_bitrate , \"source_audio_samplerate\" : self . __default_audio_samplerate , \"source_has_video\" : self . __contains_video , \"source_has_audio\" : self . __contains_audio , \"source_has_image_sequence\" : self . __contains_images , } return metadata def __validate_source ( self , source ): \"\"\" Internal method for validating source and extract its FFmpeg metadata. \"\"\" if source is None or not source or not isinstance ( source , str ): raise ValueError ( \"Input source is empty!\" ) # Differentiate input if os . path . isfile ( source ): self . __video_source = os . path . abspath ( source ) elif is_valid_image_seq ( self . __ffmpeg , source = source , verbose = self . __verbose_logs ): self . __video_source = source self . __contains_images = True elif is_valid_url ( self . __ffmpeg , url = source , verbose = self . __verbose_logs ): self . __video_source = source elif self . __forcevalidatesource : logger . critical ( \"Forcefully passing validation test for given source!\" ) self . __video_source = source else : logger . error ( \"`source` value is unusable or unsupported!\" ) # discard the value otherwise raise ValueError ( \"Input source is invalid. Aborting!\" ) # extract metadata metadata = check_sp_output ( [ self . __ffmpeg , \"-hide_banner\" , \"-i\" , source ], force_retrieve_stderr = True ) # filter and return return metadata . decode ( \"utf-8\" ) . strip () def __extract_video_bitrate ( self , default_stream = 0 ): \"\"\" Parses default video-stream bitrate from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] video_bitrate_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if video_bitrate_text : selected_stream = video_bitrate_text [ default_stream if default_stream > 0 and default_stream < len ( video_bitrate_text ) else 0 ] filtered_bitrate = re . findall ( r \",\\s[0-9]+\\s\\w\\w[\\/]s\" , selected_stream . strip () ) if len ( filtered_bitrate ): default_video_bitrate = filtered_bitrate [ 0 ] . split ( \" \" )[ 1 : 3 ] final_bitrate = \" {}{} \" . format ( int ( default_video_bitrate [ 0 ] . strip ()), \"k\" if ( default_video_bitrate [ 1 ] . strip () . startswith ( \"k\" )) else \"M\" , ) return final_bitrate return \"\" def __extract_video_decoder ( self , default_stream = 0 ): \"\"\" Parses default video-stream decoder from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" assert isinstance ( default_stream , int ), \"Invalid input!\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] filtered_pixfmt = re . findall ( r \"Video:\\s[a-z0-9_-]*\" , selected_stream . strip () ) if filtered_pixfmt : return filtered_pixfmt [ 0 ] . split ( \" \" )[ - 1 ] return \"\" def __extract_video_pixfmt ( self , default_stream = 0 ): \"\"\" Parses default video-stream pixel format from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] filtered_pixfmt = re . findall ( r \",\\s[a-z][a-z0-9_-]*\" , selected_stream . strip () ) if filtered_pixfmt : return filtered_pixfmt [ 0 ] . split ( \" \" )[ - 1 ] return \"\" def __extract_audio_bitrate_nd_samplerate ( self , default_stream = 0 ): \"\"\" Parses default audio-stream bitrate and samplerate from metadata. Parameters: default_stream (int): selects specific audio-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Audio:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] result = {} if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] # filter data filtered_audio_bitrate = re . findall ( r \"fltp,\\s[0-9]+\\s\\w\\w[\\/]s\" , selected_stream . strip () ) filtered_audio_samplerate = re . findall ( r \",\\s[0-9]+\\sHz\" , selected_stream . strip () ) # get audio bitrate and samplerate metadata if filtered_audio_bitrate : filtered = filtered_audio_bitrate [ 0 ] . split ( \" \" )[ 1 : 3 ] result [ \"bitrate\" ] = \" {}{} \" . format ( int ( filtered [ 0 ] . strip ()), \"k\" if ( filtered [ 1 ] . strip () . startswith ( \"k\" )) else \"M\" , ) else : result [ \"bitrate\" ] = \"\" if filtered_audio_samplerate : result [ \"samplerate\" ] = filtered_audio_samplerate [ 0 ] . split ( \", \" )[ 1 ] else : result [ \"samplerate\" ] = \"\" return result if result and ( len ( result ) == 2 ) else {} def __extract_resolution_framerate ( self , default_stream = 0 ): \"\"\" Parses default video-stream resolution and framerate from metadata. **Returns:** A dictionary value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] result = {} if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] # filter data filtered_resolution = re . findall ( r \"([1-9]\\d+)x([1-9]\\d+)\" , selected_stream . strip () ) filtered_framerate = re . findall ( r \"\\d+(?:\\.\\d+)?\\sfps\" , selected_stream . strip () ) # get framerate and resolution metadata if filtered_framerate : result [ \"framerate\" ] = float ( re . findall ( r \"[\\d\\.\\d]+\" , filtered_framerate [ 0 ])[ 0 ] ) if filtered_resolution : result [ \"resolution\" ] = [ int ( x ) for x in filtered_resolution [ 0 ]] return result if result and ( len ( result ) == 2 ) else {} def __extract_duration ( self , inseconds = True ): \"\"\" Parses stream duration from metadata. **Returns:** A string value. \"\"\" identifiers = [ \"Duration:\" ] stripped_data = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if stripped_data : t_duration = re . findall ( r \"(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d+(?:\\.\\d+)?)\" , stripped_data [ 0 ], ) if t_duration : return ( sum ( float ( x ) * 60 ** i for i , x in enumerate ( reversed ( t_duration [ 0 ] . split ( \":\" ))) ) if inseconds else t_duration ) return 0 __init__ ( self , source , custom_ffmpeg = '' , verbose = False , ** sourcer_params ) special \u00b6 This constructor method initializes the object state and attributes of the Sourcer. Parameters: Name Type Description Default source str defines the default input source. required verbose bool enables/disables verbose. False custom_ffmpeg str assigns the location of custom path/directory for custom FFmpeg executable. '' sourcer_params dict provides the flexibility to control supported internal Sourcer parameters. {} Source code in deffcode/sourcer.py def __init__ ( self , source , custom_ffmpeg = \"\" , verbose = False , ** sourcer_params ): \"\"\" This constructor method initializes the object state and attributes of the Sourcer. Parameters: source (str): defines the default input source. verbose (bool): enables/disables verbose. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. sourcer_params (dict): provides the flexibility to control supported internal Sourcer parameters. \"\"\" # checks if machine in-use is running windows os or not self . __os_windows = True if os . name == \"nt\" else False # define internal parameters self . __verbose_logs = ( # enable verbose if specified verbose if ( verbose and isinstance ( verbose , bool )) else False ) self . __ffsp_output = None # handles metadata received self . __sourcer_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in sourcer_params . items () } # handle whether to force validate source self . __forcevalidatesource = self . __sourcer_params . pop ( \"-force_validate_source\" , False ) if not isinstance ( self . __forcevalidatesource , bool ): # reset improper values self . __forcevalidatesource = False # handle where to save the downloaded FFmpeg Static assets on Windows(if specified) __ffmpeg_download_path = self . __sourcer_params . pop ( \"-ffmpeg_download_path\" , \"\" ) if not isinstance ( __ffmpeg_download_path , str ): # reset improper values __ffmpeg_download_path = \"\" # validate the FFmpeg assets and return location (also downloads static assets on windows) self . __ffmpeg = get_valid_ffmpeg_path ( str ( custom_ffmpeg ), self . __os_windows , ffmpeg_download_path = __ffmpeg_download_path , verbose = self . __verbose_logs , ) # check if valid FFmpeg path returned if self . __ffmpeg : self . __verbose_logs and logger . debug ( \"Found valid FFmpeg executable: ` {} `.\" . format ( self . __ffmpeg ) ) else : # else raise error raise RuntimeError ( \"[DeFFcode:ERROR] :: Failed to find FFmpeg assets on this system. Kindly compile/install FFmpeg or provide a valid custom FFmpeg binary path!\" ) # define externally accessible parameters self . __source = source # handles source stream self . __source_extension = os . path . splitext ( source )[ - 1 ] # handles source stream extension self . __default_video_resolution = \"\" # handle stream resolution self . __default_video_framerate = \"\" # handle stream framerate self . __default_video_bitrate = \"\" # handle stream's video bitrate self . __default_video_pixfmt = \"\" # handle stream's video pixfmt self . __default_video_decoder = \"\" # handle stream's video decoder self . __default_source_duration = \"\" # handle stream's video duration self . __approx_video_nframes = \"\" # handle approx stream frame number self . __default_audio_bitrate = \"\" # handle stream's audio bitrate self . __default_audio_samplerate = \"\" # handle stream's audio samplerate # handle flags self . __contains_video = False # contain video self . __contains_audio = False # contain audio self . __contains_images = False # contain image-sequence # check whether metadata probed or not self . __metadata_probed = False probe_stream ( self , default_stream_indexes = ( 0 , 0 )) \u00b6 Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: Name Type Description Default default_stream_indexes list, tuple selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0 th video stream\", \"1 st audio stream\"). (0, 0) Returns: Reference to the instance object. Source code in deffcode/sourcer.py def probe_stream ( self , default_stream_indexes = ( 0 , 0 )): \"\"\" Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: default_stream_indexes (list, tuple): selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0th video stream\", \"1st audio stream\"). **Returns:** Reference to the instance object. \"\"\" assert ( isinstance ( default_stream_indexes , ( list , tuple )) and len ( default_stream_indexes ) == 2 and all ( isinstance ( x , int ) for x in default_stream_indexes ) ), \"Invalid default_stream_indexes value!\" # validate source and extract metadata self . __ffsp_output = self . __validate_source ( self . __source ) # parse resolution and framerate video_rfparams = self . __extract_resolution_framerate ( default_stream = default_stream_indexes [ 0 ] ) if video_rfparams : self . __default_video_resolution = video_rfparams [ \"resolution\" ] self . __default_video_framerate = video_rfparams [ \"framerate\" ] # parse pixel format self . __default_video_pixfmt = self . __extract_video_pixfmt ( default_stream = default_stream_indexes [ 0 ] ) # parse video decoder self . __default_video_decoder = self . __extract_video_decoder ( default_stream = default_stream_indexes [ 0 ] ) # parse rest of metadata if not self . __contains_images : # parse video bitrate self . __default_video_bitrate = self . __extract_video_bitrate ( default_stream = default_stream_indexes [ 0 ] ) # parse audio bitrate and samplerate audio_params = self . __extract_audio_bitrate_nd_samplerate ( default_stream = default_stream_indexes [ 1 ] ) if audio_params : self . __default_audio_bitrate = audio_params [ \"bitrate\" ] self . __default_audio_samplerate = audio_params [ \"samplerate\" ] # parse video duration self . __default_source_duration = self . __extract_duration () # calculate all flags if ( self . __default_video_bitrate or self . __default_video_framerate ) and ( self . __default_audio_bitrate or self . __default_audio_samplerate ): self . __contains_video = True self . __contains_audio = True elif self . __default_video_bitrate or self . __default_video_framerate : self . __contains_video = True elif self . __default_audio_bitrate or self . __default_audio_samplerate : self . __contains_audio = True else : raise IOError ( \"Invalid source provided. No usable Audio/Video stream detected. Aborting!!!\" ) # calculate approximate number of video frame if self . __default_video_framerate and self . __default_source_duration : self . __approx_video_nframes = np . rint ( self . __default_video_framerate * self . __default_source_duration ) . astype ( int , casting = \"unsafe\" ) # signal metadata has been probed self . __metadata_probed = True # return reference to the instance object. return self retrieve_metadata ( self ) \u00b6 Returns Source metadata formatted as python dictionary. Returns: A dictionary value containing metadata. Source code in deffcode/sourcer.py def retrieve_metadata ( self ): \"\"\" Returns Source metadata formatted as python dictionary. **Returns:** A dictionary value containing metadata. \"\"\" # check if metadata has been probed or not assert ( self . __metadata_probed ), \"Source Metadata not been probed yet! Check if you called `probe_stream()` method.\" self . __verbose_logs and logger . debug ( \"Retrieving Metadata...\" ) metadata = { \"ffmpeg_binary_path\" : self . __ffmpeg , \"source\" : self . __source , \"source_extension\" : self . __source_extension , \"source_video_resolution\" : self . __default_video_resolution , \"source_video_framerate\" : self . __default_video_framerate , \"source_video_pixfmt\" : self . __default_video_pixfmt , \"source_video_decoder\" : self . __default_video_decoder , \"source_duration_sec\" : self . __default_source_duration , \"approx_video_nframes\" : int ( self . __approx_video_nframes ) if self . __approx_video_nframes else None , \"source_video_bitrate\" : self . __default_video_bitrate , \"source_audio_bitrate\" : self . __default_audio_bitrate , \"source_audio_samplerate\" : self . __default_audio_samplerate , \"source_has_video\" : self . __contains_video , \"source_has_audio\" : self . __contains_audio , \"source_has_image_sequence\" : self . __contains_images , } return metadata","title":"API"},{"location":"reference/sourcer/#sourcer-api","text":"DeFFcode's Sourcer API acts as Source Validator and Classifier (just like talent sourcer ) for its FFdecoder API . This API parses FFmpeg's subprocess output for a given source and uses it to validate and identify all valid streams available in it. Sourcer API also acts as a Metadata Extraction Tool that extracts metadata of all specified valid streams that FFdecoder API uses for formatting its default FFmpeg pipeline for frames generation. Furthermore, Sourcer is responsible for validating FFmpeg executable path for DeFFcode. Extracting Source Video Metadata in DeFFcode Metadata can be easily extracted as a dictionary in Sourcer API using its retrieve_metadata() method. However, you can also use metadata property object in FFdecoder API to extract metadata as Pretty JSON, and update it directly as desired. More information can be found in this usage example \u27b6 . All parameter available with Sourcer API extracted as python dictionary(On Windows), are as follows: { \"ffmpeg_binary_path\" : \"C: \\\\ Users \\\\ foo \\\\ AppData \\\\ Local \\\\ Temp \\\\ ffmpeg-static-win64-gpl/bin/ffmpeg.exe\" , \"source\" : \"foo.mp4\" , \"source_extension\" : \".mp4\" , \"source_video_resolution\" : [ 1280 , 720 ], \"source_video_framerate\" : 25.0 , \"source_video_pixfmt\" : \"yuv420p\" , \"source_video_decoder\" : \"h264\" , \"source_duration_sec\" : 5.31 , \"approx_video_nframes\" : 133 , \"source_video_bitrate\" : \"1205k\" , \"source_audio_bitrate\" : \"384k\" , \"source_audio_samplerate\" : \"48000 Hz\" , \"source_has_video\" : True , \"source_has_audio\" : True , \"source_has_image_sequence\" : False , } \u2009 For usage, kindly refer our Basic Recipes and Advanced Recipes Sourcer API parameters are explained here \u27b6 Source code in deffcode/sourcer.py class Sourcer : \"\"\" \"\"\" def __init__ ( self , source , custom_ffmpeg = \"\" , verbose = False , ** sourcer_params ): \"\"\" This constructor method initializes the object state and attributes of the Sourcer. Parameters: source (str): defines the default input source. verbose (bool): enables/disables verbose. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. sourcer_params (dict): provides the flexibility to control supported internal Sourcer parameters. \"\"\" # checks if machine in-use is running windows os or not self . __os_windows = True if os . name == \"nt\" else False # define internal parameters self . __verbose_logs = ( # enable verbose if specified verbose if ( verbose and isinstance ( verbose , bool )) else False ) self . __ffsp_output = None # handles metadata received self . __sourcer_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in sourcer_params . items () } # handle whether to force validate source self . __forcevalidatesource = self . __sourcer_params . pop ( \"-force_validate_source\" , False ) if not isinstance ( self . __forcevalidatesource , bool ): # reset improper values self . __forcevalidatesource = False # handle where to save the downloaded FFmpeg Static assets on Windows(if specified) __ffmpeg_download_path = self . __sourcer_params . pop ( \"-ffmpeg_download_path\" , \"\" ) if not isinstance ( __ffmpeg_download_path , str ): # reset improper values __ffmpeg_download_path = \"\" # validate the FFmpeg assets and return location (also downloads static assets on windows) self . __ffmpeg = get_valid_ffmpeg_path ( str ( custom_ffmpeg ), self . __os_windows , ffmpeg_download_path = __ffmpeg_download_path , verbose = self . __verbose_logs , ) # check if valid FFmpeg path returned if self . __ffmpeg : self . __verbose_logs and logger . debug ( \"Found valid FFmpeg executable: ` {} `.\" . format ( self . __ffmpeg ) ) else : # else raise error raise RuntimeError ( \"[DeFFcode:ERROR] :: Failed to find FFmpeg assets on this system. Kindly compile/install FFmpeg or provide a valid custom FFmpeg binary path!\" ) # define externally accessible parameters self . __source = source # handles source stream self . __source_extension = os . path . splitext ( source )[ - 1 ] # handles source stream extension self . __default_video_resolution = \"\" # handle stream resolution self . __default_video_framerate = \"\" # handle stream framerate self . __default_video_bitrate = \"\" # handle stream's video bitrate self . __default_video_pixfmt = \"\" # handle stream's video pixfmt self . __default_video_decoder = \"\" # handle stream's video decoder self . __default_source_duration = \"\" # handle stream's video duration self . __approx_video_nframes = \"\" # handle approx stream frame number self . __default_audio_bitrate = \"\" # handle stream's audio bitrate self . __default_audio_samplerate = \"\" # handle stream's audio samplerate # handle flags self . __contains_video = False # contain video self . __contains_audio = False # contain audio self . __contains_images = False # contain image-sequence # check whether metadata probed or not self . __metadata_probed = False def probe_stream ( self , default_stream_indexes = ( 0 , 0 )): \"\"\" Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: default_stream_indexes (list, tuple): selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0th video stream\", \"1st audio stream\"). **Returns:** Reference to the instance object. \"\"\" assert ( isinstance ( default_stream_indexes , ( list , tuple )) and len ( default_stream_indexes ) == 2 and all ( isinstance ( x , int ) for x in default_stream_indexes ) ), \"Invalid default_stream_indexes value!\" # validate source and extract metadata self . __ffsp_output = self . __validate_source ( self . __source ) # parse resolution and framerate video_rfparams = self . __extract_resolution_framerate ( default_stream = default_stream_indexes [ 0 ] ) if video_rfparams : self . __default_video_resolution = video_rfparams [ \"resolution\" ] self . __default_video_framerate = video_rfparams [ \"framerate\" ] # parse pixel format self . __default_video_pixfmt = self . __extract_video_pixfmt ( default_stream = default_stream_indexes [ 0 ] ) # parse video decoder self . __default_video_decoder = self . __extract_video_decoder ( default_stream = default_stream_indexes [ 0 ] ) # parse rest of metadata if not self . __contains_images : # parse video bitrate self . __default_video_bitrate = self . __extract_video_bitrate ( default_stream = default_stream_indexes [ 0 ] ) # parse audio bitrate and samplerate audio_params = self . __extract_audio_bitrate_nd_samplerate ( default_stream = default_stream_indexes [ 1 ] ) if audio_params : self . __default_audio_bitrate = audio_params [ \"bitrate\" ] self . __default_audio_samplerate = audio_params [ \"samplerate\" ] # parse video duration self . __default_source_duration = self . __extract_duration () # calculate all flags if ( self . __default_video_bitrate or self . __default_video_framerate ) and ( self . __default_audio_bitrate or self . __default_audio_samplerate ): self . __contains_video = True self . __contains_audio = True elif self . __default_video_bitrate or self . __default_video_framerate : self . __contains_video = True elif self . __default_audio_bitrate or self . __default_audio_samplerate : self . __contains_audio = True else : raise IOError ( \"Invalid source provided. No usable Audio/Video stream detected. Aborting!!!\" ) # calculate approximate number of video frame if self . __default_video_framerate and self . __default_source_duration : self . __approx_video_nframes = np . rint ( self . __default_video_framerate * self . __default_source_duration ) . astype ( int , casting = \"unsafe\" ) # signal metadata has been probed self . __metadata_probed = True # return reference to the instance object. return self def retrieve_metadata ( self ): \"\"\" Returns Source metadata formatted as python dictionary. **Returns:** A dictionary value containing metadata. \"\"\" # check if metadata has been probed or not assert ( self . __metadata_probed ), \"Source Metadata not been probed yet! Check if you called `probe_stream()` method.\" self . __verbose_logs and logger . debug ( \"Retrieving Metadata...\" ) metadata = { \"ffmpeg_binary_path\" : self . __ffmpeg , \"source\" : self . __source , \"source_extension\" : self . __source_extension , \"source_video_resolution\" : self . __default_video_resolution , \"source_video_framerate\" : self . __default_video_framerate , \"source_video_pixfmt\" : self . __default_video_pixfmt , \"source_video_decoder\" : self . __default_video_decoder , \"source_duration_sec\" : self . __default_source_duration , \"approx_video_nframes\" : int ( self . __approx_video_nframes ) if self . __approx_video_nframes else None , \"source_video_bitrate\" : self . __default_video_bitrate , \"source_audio_bitrate\" : self . __default_audio_bitrate , \"source_audio_samplerate\" : self . __default_audio_samplerate , \"source_has_video\" : self . __contains_video , \"source_has_audio\" : self . __contains_audio , \"source_has_image_sequence\" : self . __contains_images , } return metadata def __validate_source ( self , source ): \"\"\" Internal method for validating source and extract its FFmpeg metadata. \"\"\" if source is None or not source or not isinstance ( source , str ): raise ValueError ( \"Input source is empty!\" ) # Differentiate input if os . path . isfile ( source ): self . __video_source = os . path . abspath ( source ) elif is_valid_image_seq ( self . __ffmpeg , source = source , verbose = self . __verbose_logs ): self . __video_source = source self . __contains_images = True elif is_valid_url ( self . __ffmpeg , url = source , verbose = self . __verbose_logs ): self . __video_source = source elif self . __forcevalidatesource : logger . critical ( \"Forcefully passing validation test for given source!\" ) self . __video_source = source else : logger . error ( \"`source` value is unusable or unsupported!\" ) # discard the value otherwise raise ValueError ( \"Input source is invalid. Aborting!\" ) # extract metadata metadata = check_sp_output ( [ self . __ffmpeg , \"-hide_banner\" , \"-i\" , source ], force_retrieve_stderr = True ) # filter and return return metadata . decode ( \"utf-8\" ) . strip () def __extract_video_bitrate ( self , default_stream = 0 ): \"\"\" Parses default video-stream bitrate from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] video_bitrate_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if video_bitrate_text : selected_stream = video_bitrate_text [ default_stream if default_stream > 0 and default_stream < len ( video_bitrate_text ) else 0 ] filtered_bitrate = re . findall ( r \",\\s[0-9]+\\s\\w\\w[\\/]s\" , selected_stream . strip () ) if len ( filtered_bitrate ): default_video_bitrate = filtered_bitrate [ 0 ] . split ( \" \" )[ 1 : 3 ] final_bitrate = \" {}{} \" . format ( int ( default_video_bitrate [ 0 ] . strip ()), \"k\" if ( default_video_bitrate [ 1 ] . strip () . startswith ( \"k\" )) else \"M\" , ) return final_bitrate return \"\" def __extract_video_decoder ( self , default_stream = 0 ): \"\"\" Parses default video-stream decoder from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" assert isinstance ( default_stream , int ), \"Invalid input!\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] filtered_pixfmt = re . findall ( r \"Video:\\s[a-z0-9_-]*\" , selected_stream . strip () ) if filtered_pixfmt : return filtered_pixfmt [ 0 ] . split ( \" \" )[ - 1 ] return \"\" def __extract_video_pixfmt ( self , default_stream = 0 ): \"\"\" Parses default video-stream pixel format from metadata. Parameters: default_stream (int): selects specific video-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] filtered_pixfmt = re . findall ( r \",\\s[a-z][a-z0-9_-]*\" , selected_stream . strip () ) if filtered_pixfmt : return filtered_pixfmt [ 0 ] . split ( \" \" )[ - 1 ] return \"\" def __extract_audio_bitrate_nd_samplerate ( self , default_stream = 0 ): \"\"\" Parses default audio-stream bitrate and samplerate from metadata. Parameters: default_stream (int): selects specific audio-stream in case of multiple ones. **Returns:** A string value. \"\"\" identifiers = [ \"Audio:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] result = {} if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] # filter data filtered_audio_bitrate = re . findall ( r \"fltp,\\s[0-9]+\\s\\w\\w[\\/]s\" , selected_stream . strip () ) filtered_audio_samplerate = re . findall ( r \",\\s[0-9]+\\sHz\" , selected_stream . strip () ) # get audio bitrate and samplerate metadata if filtered_audio_bitrate : filtered = filtered_audio_bitrate [ 0 ] . split ( \" \" )[ 1 : 3 ] result [ \"bitrate\" ] = \" {}{} \" . format ( int ( filtered [ 0 ] . strip ()), \"k\" if ( filtered [ 1 ] . strip () . startswith ( \"k\" )) else \"M\" , ) else : result [ \"bitrate\" ] = \"\" if filtered_audio_samplerate : result [ \"samplerate\" ] = filtered_audio_samplerate [ 0 ] . split ( \", \" )[ 1 ] else : result [ \"samplerate\" ] = \"\" return result if result and ( len ( result ) == 2 ) else {} def __extract_resolution_framerate ( self , default_stream = 0 ): \"\"\" Parses default video-stream resolution and framerate from metadata. **Returns:** A dictionary value. \"\"\" identifiers = [ \"Video:\" , \"Stream #\" ] meta_text = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] result = {} if meta_text : selected_stream = meta_text [ default_stream if default_stream > 0 and default_stream < len ( meta_text ) else 0 ] # filter data filtered_resolution = re . findall ( r \"([1-9]\\d+)x([1-9]\\d+)\" , selected_stream . strip () ) filtered_framerate = re . findall ( r \"\\d+(?:\\.\\d+)?\\sfps\" , selected_stream . strip () ) # get framerate and resolution metadata if filtered_framerate : result [ \"framerate\" ] = float ( re . findall ( r \"[\\d\\.\\d]+\" , filtered_framerate [ 0 ])[ 0 ] ) if filtered_resolution : result [ \"resolution\" ] = [ int ( x ) for x in filtered_resolution [ 0 ]] return result if result and ( len ( result ) == 2 ) else {} def __extract_duration ( self , inseconds = True ): \"\"\" Parses stream duration from metadata. **Returns:** A string value. \"\"\" identifiers = [ \"Duration:\" ] stripped_data = [ line . strip () for line in self . __ffsp_output . split ( \" \\n \" ) if all ( x in line for x in identifiers ) ] if stripped_data : t_duration = re . findall ( r \"(?:[01]\\d|2[0123]):(?:[012345]\\d):(?:[012345]\\d+(?:\\.\\d+)?)\" , stripped_data [ 0 ], ) if t_duration : return ( sum ( float ( x ) * 60 ** i for i , x in enumerate ( reversed ( t_duration [ 0 ] . split ( \":\" ))) ) if inseconds else t_duration ) return 0","title":"Sourcer API"},{"location":"reference/sourcer/#deffcode.sourcer.Sourcer.__init__","text":"This constructor method initializes the object state and attributes of the Sourcer. Parameters: Name Type Description Default source str defines the default input source. required verbose bool enables/disables verbose. False custom_ffmpeg str assigns the location of custom path/directory for custom FFmpeg executable. '' sourcer_params dict provides the flexibility to control supported internal Sourcer parameters. {} Source code in deffcode/sourcer.py def __init__ ( self , source , custom_ffmpeg = \"\" , verbose = False , ** sourcer_params ): \"\"\" This constructor method initializes the object state and attributes of the Sourcer. Parameters: source (str): defines the default input source. verbose (bool): enables/disables verbose. custom_ffmpeg (str): assigns the location of custom path/directory for custom FFmpeg executable. sourcer_params (dict): provides the flexibility to control supported internal Sourcer parameters. \"\"\" # checks if machine in-use is running windows os or not self . __os_windows = True if os . name == \"nt\" else False # define internal parameters self . __verbose_logs = ( # enable verbose if specified verbose if ( verbose and isinstance ( verbose , bool )) else False ) self . __ffsp_output = None # handles metadata received self . __sourcer_params = { str ( k ) . strip (): str ( v ) . strip () if not isinstance ( v , ( dict , list , int , float )) else v for k , v in sourcer_params . items () } # handle whether to force validate source self . __forcevalidatesource = self . __sourcer_params . pop ( \"-force_validate_source\" , False ) if not isinstance ( self . __forcevalidatesource , bool ): # reset improper values self . __forcevalidatesource = False # handle where to save the downloaded FFmpeg Static assets on Windows(if specified) __ffmpeg_download_path = self . __sourcer_params . pop ( \"-ffmpeg_download_path\" , \"\" ) if not isinstance ( __ffmpeg_download_path , str ): # reset improper values __ffmpeg_download_path = \"\" # validate the FFmpeg assets and return location (also downloads static assets on windows) self . __ffmpeg = get_valid_ffmpeg_path ( str ( custom_ffmpeg ), self . __os_windows , ffmpeg_download_path = __ffmpeg_download_path , verbose = self . __verbose_logs , ) # check if valid FFmpeg path returned if self . __ffmpeg : self . __verbose_logs and logger . debug ( \"Found valid FFmpeg executable: ` {} `.\" . format ( self . __ffmpeg ) ) else : # else raise error raise RuntimeError ( \"[DeFFcode:ERROR] :: Failed to find FFmpeg assets on this system. Kindly compile/install FFmpeg or provide a valid custom FFmpeg binary path!\" ) # define externally accessible parameters self . __source = source # handles source stream self . __source_extension = os . path . splitext ( source )[ - 1 ] # handles source stream extension self . __default_video_resolution = \"\" # handle stream resolution self . __default_video_framerate = \"\" # handle stream framerate self . __default_video_bitrate = \"\" # handle stream's video bitrate self . __default_video_pixfmt = \"\" # handle stream's video pixfmt self . __default_video_decoder = \"\" # handle stream's video decoder self . __default_source_duration = \"\" # handle stream's video duration self . __approx_video_nframes = \"\" # handle approx stream frame number self . __default_audio_bitrate = \"\" # handle stream's audio bitrate self . __default_audio_samplerate = \"\" # handle stream's audio samplerate # handle flags self . __contains_video = False # contain video self . __contains_audio = False # contain audio self . __contains_images = False # contain image-sequence # check whether metadata probed or not self . __metadata_probed = False","title":"__init__()"},{"location":"reference/sourcer/#deffcode.sourcer.Sourcer.probe_stream","text":"Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: Name Type Description Default default_stream_indexes list, tuple selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0 th video stream\", \"1 st audio stream\"). (0, 0) Returns: Reference to the instance object. Source code in deffcode/sourcer.py def probe_stream ( self , default_stream_indexes = ( 0 , 0 )): \"\"\" Parses Source's FFmpeg Output and populates metadata in private class variables Parameters: default_stream_indexes (list, tuple): selects specific video and audio stream index in case of multiple ones. Value can be of format: (int,int). For example (0,1) is (\"0th video stream\", \"1st audio stream\"). **Returns:** Reference to the instance object. \"\"\" assert ( isinstance ( default_stream_indexes , ( list , tuple )) and len ( default_stream_indexes ) == 2 and all ( isinstance ( x , int ) for x in default_stream_indexes ) ), \"Invalid default_stream_indexes value!\" # validate source and extract metadata self . __ffsp_output = self . __validate_source ( self . __source ) # parse resolution and framerate video_rfparams = self . __extract_resolution_framerate ( default_stream = default_stream_indexes [ 0 ] ) if video_rfparams : self . __default_video_resolution = video_rfparams [ \"resolution\" ] self . __default_video_framerate = video_rfparams [ \"framerate\" ] # parse pixel format self . __default_video_pixfmt = self . __extract_video_pixfmt ( default_stream = default_stream_indexes [ 0 ] ) # parse video decoder self . __default_video_decoder = self . __extract_video_decoder ( default_stream = default_stream_indexes [ 0 ] ) # parse rest of metadata if not self . __contains_images : # parse video bitrate self . __default_video_bitrate = self . __extract_video_bitrate ( default_stream = default_stream_indexes [ 0 ] ) # parse audio bitrate and samplerate audio_params = self . __extract_audio_bitrate_nd_samplerate ( default_stream = default_stream_indexes [ 1 ] ) if audio_params : self . __default_audio_bitrate = audio_params [ \"bitrate\" ] self . __default_audio_samplerate = audio_params [ \"samplerate\" ] # parse video duration self . __default_source_duration = self . __extract_duration () # calculate all flags if ( self . __default_video_bitrate or self . __default_video_framerate ) and ( self . __default_audio_bitrate or self . __default_audio_samplerate ): self . __contains_video = True self . __contains_audio = True elif self . __default_video_bitrate or self . __default_video_framerate : self . __contains_video = True elif self . __default_audio_bitrate or self . __default_audio_samplerate : self . __contains_audio = True else : raise IOError ( \"Invalid source provided. No usable Audio/Video stream detected. Aborting!!!\" ) # calculate approximate number of video frame if self . __default_video_framerate and self . __default_source_duration : self . __approx_video_nframes = np . rint ( self . __default_video_framerate * self . __default_source_duration ) . astype ( int , casting = \"unsafe\" ) # signal metadata has been probed self . __metadata_probed = True # return reference to the instance object. return self","title":"probe_stream()"},{"location":"reference/sourcer/#deffcode.sourcer.Sourcer.retrieve_metadata","text":"Returns Source metadata formatted as python dictionary. Returns: A dictionary value containing metadata. Source code in deffcode/sourcer.py def retrieve_metadata ( self ): \"\"\" Returns Source metadata formatted as python dictionary. **Returns:** A dictionary value containing metadata. \"\"\" # check if metadata has been probed or not assert ( self . __metadata_probed ), \"Source Metadata not been probed yet! Check if you called `probe_stream()` method.\" self . __verbose_logs and logger . debug ( \"Retrieving Metadata...\" ) metadata = { \"ffmpeg_binary_path\" : self . __ffmpeg , \"source\" : self . __source , \"source_extension\" : self . __source_extension , \"source_video_resolution\" : self . __default_video_resolution , \"source_video_framerate\" : self . __default_video_framerate , \"source_video_pixfmt\" : self . __default_video_pixfmt , \"source_video_decoder\" : self . __default_video_decoder , \"source_duration_sec\" : self . __default_source_duration , \"approx_video_nframes\" : int ( self . __approx_video_nframes ) if self . __approx_video_nframes else None , \"source_video_bitrate\" : self . __default_video_bitrate , \"source_audio_bitrate\" : self . __default_audio_bitrate , \"source_audio_samplerate\" : self . __default_audio_samplerate , \"source_has_video\" : self . __contains_video , \"source_has_audio\" : self . __contains_audio , \"source_has_image_sequence\" : self . __contains_images , } return metadata","title":"retrieve_metadata()"},{"location":"reference/sourcer/params/","text":"Sourcer API Parameters \u00b6 source \u00b6 Sourcer API will throw RuntimeError if source provided is invalid or missing. This parameter defines the default input source. Data-Type: String. Its valid input can be one of the following: Filepath: Valid path of the video file, for e.g \"/home/foo.mp4\" as follows: Multiple video file paths are not yet support! decoder = Sourcer ( '/home/foo.mp4' ) . formulate () Image Sequence: Valid image sequence such as sequential 'img%03d.png' or '*.png' glob pattern or even single(loop) image as input: Sequential Glob pattern Single image # initialize and formulate the decoder decoder = Sourcer ( 'img %03d .png' ) . formulate () You can use -start_number FFmpeg parameter if you want to start with specific number: # define `-start_number` such as `5` sourcer_params = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img %03d .png' , verbose = True , ** sourcer_params ) . formulate () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. You can do it as follows: The glob pattern is not available on Windows builds. # define `-pattern_type glob` for accepting glob pattern sourcer_params = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img*.png' , verbose = True , ** sourcer_params ) . formulate () You can use a single looping image as follows: # define `-loop 1` for looping sourcer_params = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img.jpg' , verbose = True , ** sourcer_params ) . formulate () Network Address: Valid ( http(s) , rtp , rstp , rtmp , mms , etc.) incoming network stream address such as 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' as input: # define `rtsp_transport` or necessary parameters sourcer_params = { \"-ffpostfixes\" :[ \"-rtsp_transport\" , \"tcp\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' , verbose = True , ** sourcer_params ) . formulate () Video Input devices: (Yet to be supported) Screen Capture: (Yet to be supported) custom_ffmpeg \u00b6 This parameter assigns the custom path/directory where the custom/downloaded FFmpeg executables are located. Behavior on Windows If a custom FFmpeg executable's path | directory is not provided through custom_ffmpeg parameter on Windows machine, then Sourcer API will automatically attempt to download and extract suitable Static FFmpeg binaries at suitable location on your windows machine . More information can be found here \u27b6 . Data-Type: String Default Value: Its default value is None . Usage: # If ffmpeg executables are located at \"/foo/foo1/ffmpeg\" Sourcer ( \"foo.mp4\" , custom_ffmpeg = \"/foo/foo1/ffmpeg\" ) . formulate () verbose \u00b6 This parameter enables verbose (if True ) , essential for debugging. Data-Type: Boolean Default Value: Its default value is False . Usage: Sourcer ( \"foo.mp4\" , verbose = True ) . formulate () sourcer_params \u00b6 This parameter accepts few Exclusive Parameters formatted as as its attributes: Kindly read docs carefully before passing any additional values to sourcer_params parameter. Wrong invalid values may result in undesired errors or no output at all. Data-Type: Dictionary Default Value: Its default value is {} . Exclusive Parameters \u00b6 Sourcer API supports only few Exclusive Parameters to flexibly alter its internal properties. These parameters are discussed below: -ffmpeg_download_path (string) : sets the custom directory for downloading FFmpeg Static Binaries in Compression Mode, during the Auto-Installation on Windows Machines Only. If this parameter is not altered, then these binaries will auto-save to the default temporary directory (for e.g. C:/User/temp ) on your windows machine. It can be used as follows: sourcer_params = { \"-ffmpeg_download_path\" : \"C:/User/foo/foo1\" } # will be saved to \"C:/User/foo/foo1\" -force_validate_source (bool) : forcefully passes validation test for given source which is required for some special cases with unusual input. It can be used as follows: sourcer_params = { \"-force_validate_source\" : True } # will pass validation test forcefully","title":"API Parameters"},{"location":"reference/sourcer/params/#sourcer-api-parameters","text":"","title":"Sourcer API Parameters"},{"location":"reference/sourcer/params/#source","text":"Sourcer API will throw RuntimeError if source provided is invalid or missing. This parameter defines the default input source. Data-Type: String. Its valid input can be one of the following: Filepath: Valid path of the video file, for e.g \"/home/foo.mp4\" as follows: Multiple video file paths are not yet support! decoder = Sourcer ( '/home/foo.mp4' ) . formulate () Image Sequence: Valid image sequence such as sequential 'img%03d.png' or '*.png' glob pattern or even single(loop) image as input: Sequential Glob pattern Single image # initialize and formulate the decoder decoder = Sourcer ( 'img %03d .png' ) . formulate () You can use -start_number FFmpeg parameter if you want to start with specific number: # define `-start_number` such as `5` sourcer_params = { \"-ffpostfixes\" :[ \"-start_number\" , \"5\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img %03d .png' , verbose = True , ** sourcer_params ) . formulate () Bash-style globbing ( * represents any number of any characters) is useful if your images are sequential but not necessarily in a numerically sequential order. You can do it as follows: The glob pattern is not available on Windows builds. # define `-pattern_type glob` for accepting glob pattern sourcer_params = { \"-ffprefixes\" :[ \"-pattern_type\" , \"glob\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img*.png' , verbose = True , ** sourcer_params ) . formulate () You can use a single looping image as follows: # define `-loop 1` for looping sourcer_params = { \"-ffprefixes\" :[ \"-loop\" , \"1\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'img.jpg' , verbose = True , ** sourcer_params ) . formulate () Network Address: Valid ( http(s) , rtp , rstp , rtmp , mms , etc.) incoming network stream address such as 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' as input: # define `rtsp_transport` or necessary parameters sourcer_params = { \"-ffpostfixes\" :[ \"-rtsp_transport\" , \"tcp\" ]} # initialize and formulate the decoder with define parameters decoder = Sourcer ( 'rtsp://xx:yy@192.168.1.ee:fd/av0_0' , verbose = True , ** sourcer_params ) . formulate () Video Input devices: (Yet to be supported) Screen Capture: (Yet to be supported)","title":"source"},{"location":"reference/sourcer/params/#custom_ffmpeg","text":"This parameter assigns the custom path/directory where the custom/downloaded FFmpeg executables are located. Behavior on Windows If a custom FFmpeg executable's path | directory is not provided through custom_ffmpeg parameter on Windows machine, then Sourcer API will automatically attempt to download and extract suitable Static FFmpeg binaries at suitable location on your windows machine . More information can be found here \u27b6 . Data-Type: String Default Value: Its default value is None . Usage: # If ffmpeg executables are located at \"/foo/foo1/ffmpeg\" Sourcer ( \"foo.mp4\" , custom_ffmpeg = \"/foo/foo1/ffmpeg\" ) . formulate ()","title":"custom_ffmpeg"},{"location":"reference/sourcer/params/#verbose","text":"This parameter enables verbose (if True ) , essential for debugging. Data-Type: Boolean Default Value: Its default value is False . Usage: Sourcer ( \"foo.mp4\" , verbose = True ) . formulate ()","title":"verbose"},{"location":"reference/sourcer/params/#sourcer_params","text":"This parameter accepts few Exclusive Parameters formatted as as its attributes: Kindly read docs carefully before passing any additional values to sourcer_params parameter. Wrong invalid values may result in undesired errors or no output at all. Data-Type: Dictionary Default Value: Its default value is {} .","title":"sourcer_params"},{"location":"reference/sourcer/params/#exclusive-parameters","text":"Sourcer API supports only few Exclusive Parameters to flexibly alter its internal properties. These parameters are discussed below: -ffmpeg_download_path (string) : sets the custom directory for downloading FFmpeg Static Binaries in Compression Mode, during the Auto-Installation on Windows Machines Only. If this parameter is not altered, then these binaries will auto-save to the default temporary directory (for e.g. C:/User/temp ) on your windows machine. It can be used as follows: sourcer_params = { \"-ffmpeg_download_path\" : \"C:/User/foo/foo1\" } # will be saved to \"C:/User/foo/foo1\" -force_validate_source (bool) : forcefully passes validation test for given source which is required for some special cases with unusual input. It can be used as follows: sourcer_params = { \"-force_validate_source\" : True } # will pass validation test forcefully","title":"Exclusive Parameters"}]}